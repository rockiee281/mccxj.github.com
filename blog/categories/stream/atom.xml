<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: stream | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/stream/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-10-29T22:01:31+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从流关闭说起]]></title>
    <link href="http://mccxj.github.com/blog/20130821_java-hell-stream-close.html"/>
    <updated>2013-08-21T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/java-hell-stream-close</id>
    <content type="html"><![CDATA[<h3>基本原则: 谁生产谁销毁</h3>

<p>这个是用来解决责任权的问题，例如你的方法接收一个InputStream作为参数，通常就不应该在方法内去关闭它，而由客户端代码去处理。如果要关闭，通常应该在方法签名上明确说明，具体样例参考commons-io的IOUtils类。</p>

<p>还有另外一个例子，就是经常使用的Servlet的输入输出流，根据这个原则，也是不应该在代码中进行关闭的，这个工作是由Web容器负责的。</p>

<h3>关闭的是什么?</h3>

<p>java本身是带GC的，所以对象在消除引用之后，按正常是能够被回收的，那么为什么会有关闭操作?</p>

<p>这是为了回收系统资源，主要是端口(网络IO),文件句柄(输入输出)等，通常涉及的场景也是操作文件，网络操作、数据库应用等。对于类unix系统，所有东西都是抽象成文件的，所以可以通过lsof来观察。</p>

<p>为了更详细的说明这点，我们可以测试一下下面的代码:</p>

<p>```java
public class Hello {</p>

<pre><code>public static void main(String[] args) throws Exception {
    for (int i = 0; i &lt; 100; i++) {
        FileInputStream is = new FileInputStream("/tmp/data/data"+i);
        byte[] bs = new byte[512];
        int len;
        while ((len = is.read(bs)) != -1) ;
        Thread.sleep(1000L);
    }
    Thread.sleep(10000L);
}
</code></pre>

<p>}
```</p>

<p>运行之后，通过losf或进程目录查看相关的文件句柄数量是不断增长的:</p>

<p>```bash
lsof -p 25945 |grep /tmp/data | wc -l
88</p>

<p>ls  /proc/25945/fd | wc -l
93
```</p>

<p>如果有关闭操作的话，就会发现打开文件数一直都处于很低的位置。如果持续出现未关闭的情况，积累到一定程度就可能超过系统限制，出现too many open files的错误。</p>

<h3>如何确保关闭</h3>

<p>关闭通常是调用close()方法来实现的，并且需要在finally来进行处理。另外，我们经常会遇到多个资源的关闭情况，因为IO库是采用修饰器模式的，所以基本原则是先关闭外层对象，再关闭内层对象，每个close调用都需要处理异常情况，例如:</p>

<p>```java
InputStream is = null;
OutputStream os = null;
try{
   // ...
}
finally{
  if(is != null)</p>

<pre><code> try{
   is.close();
 }
 catch(IOException e){}
</code></pre>

<p>  if(os != null)</p>

<pre><code> try{
   os.close()
 }
 catch(IOException e){}
</code></pre>

<p>}
```</p>

<h3>实践</h3>

<ul>
<li>上面的关闭处理的确是比较繁琐的，可以考虑进行封装或者直接使用IOUtils.closeQuietly方法，节约不少代码行。</li>
<li>自从JDK5之后，需要进行关闭处理的对象可以考虑实现java.io.Closeable接口。这个可以让资源关闭使用同一套代码。</li>
</ul>


<h3>JDK7改进及其他思路</h3>

<p>在JDK7里，你只需要将资源定义在try()里，Java7就会在readLine抛异常时，自动关闭资源。
但是资源类必须实现java.lang.AutoCloseable接口，同时支持管理多个资源,释放次序与声明次序相反。</p>

<p>```java
try (BufferedReader br = new BufferedReader(new FileReader(path)) {</p>

<pre><code>return br.readLine();
</code></pre>

<p>}
```</p>

<p>虽然感觉总是很繁琐，语法糖味道重，但比以前倒是进步不少了。
不过我们还是来看看Go中的做法，它提供了defer操作，用于在脱离方法作用域的时候自动调用，有点析构的味道。
看下面的示例:</p>

<p>```go
func main() {</p>

<pre><code>files, err := os.Open("testqq.txt")        
if err != nil {
    fmt.Printf("Error is:%s", "Game Over!")
    return
}
defer files.Close()
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
