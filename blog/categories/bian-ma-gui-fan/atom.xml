<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 编码规范 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/bian-ma-gui-fan/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-06-30T18:14:17+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[improve bitter code: 更友好的链式写法]]></title>
    <link href="http://mccxj.github.com/blog/20120724_improve-bitter-code-2.html"/>
    <updated>2012-07-24T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/improve-bitter-code-2</id>
    <content type="html"><![CDATA[<p><strong>备注: 示例中的代码并不是真实代码的完全拷贝</strong></p>

<h3>无意出现的链式代码</h3>

<p>还是前几天的事情，群里边有同事提到一个账单相关的需求，其中涉及到组装打印用数据。
有个新同事在Service里边写了一段这样的代码：
{% highlight java %}
public XXService fillItem(String content, String tag) {</p>

<pre><code>// some codes
this.printitems.add(new Item(tag, content));
return this;
</code></pre>

<p>}
{% endhighlight %}</p>

<p>有同学不是特别理解为什么要这么写，甚至发出return this是什么对象的疑问。</p>

<p>这段代码原来是这么写的:
{% highlight java %}
public void fillItem(String content, String tag, List printitems) {</p>

<pre><code>// some codes
printitems.add(new Item(tag, content));
</code></pre>

<p>}
{% endhighlight %}</p>

<p>有同学奇怪，为什么再提交一次printitems就会重新加一遍，认为第一段代码的问题出现在return this上面。
这样要说明一下，我们使用的是struts1，所以如果Service实例作为action的实例变量，那也是只有一个对象来的。
所以每次刷新一次重复加一遍就没什么奇怪的了。</p>

<p>回头来看那段新写的代码，出发点是好的。毕竟采用这种方式可以使用链式写法（如下所示），代码有时候会变得很sexy。
{% highlight java %}
XXService.fillItem("a", "A").fillItem("b", "B");
{% endhighlight %}
这段代码的问题不在于是否采用链式写法，而是对这种单例，变量生命周期了解不足造成的。
链式写法在代码中很少会使用到，但在设计api，也是可以考虑的。设计的好，可以有效提高代码的编写效率和api的友好型。
例如，我就对java collection api里边的add方法深恶痛绝,就是不能连续add，要add多少个就要写多少行，还真的挺烦的。</p>

<h3>采用链式写法的代码</h3>

<p>在很多有名的开源框架中，链式写法也不是很少见，下面举几个例子:</p>

<p>很常见的有jquery
{% highlight javascript %}
$("#name").attr("readonly", true).val("test");
{% endhighlight %}</p>

<p>还有mock框架mockito
{% highlight java %}
when(mockedList.get(0)).thenReturn("first");
when(mockedList.get(1)).thenThrow(new RuntimeException());
{% endhighlight %}</p>

<p>再看看rails的写法
{% highlight ruby %}
Post.where('id > 10').limit(20).order('id desc').only(:order, :where)
Client.limit(5).offset(30)
{% endhighlight %}</p>

<h3>我的看法</h3>

<p>那么，如果你想采用链式写法，有什么地方需要注意呢?
1. 先写一下客户端代码，看调用方式合理么，符合sexy api么?
2. 采用链式操作的interface相关性比较强，经常一起出现。
3. 参数parameter一般较少，因为参数多了，代码很容易变得模糊不清。
4. 链式操作要么容错强(像jquery)，要么就得直接抛出异常，对返回值不关心。</p>

<p>{% assign series_list = "improve bitter code" %}
{% include series_list.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[improve bitter code: 迷惑的boolean参数]]></title>
    <link href="http://mccxj.github.com/blog/20120724_improve-bitter-code-1.html"/>
    <updated>2012-07-24T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/improve-bitter-code-1</id>
    <content type="html"><![CDATA[<p><strong>备注: 示例中的代码并不是真实代码的完全拷贝</strong></p>

<h3>群里的讨论</h3>

<p>前两天在开发群里边，有同事讨论一个api: 增加一个取特定序列值的方法。并给出了以下的原型代码：
{% highlight java %}
public Object getSeqValue(String seqname, String maindb){</p>

<pre><code>if("1".equals(maindb)){
    DbRunContext.setRegion(DbRunContext.MAINDB);
}
// more codes
return XXDao.queryForObject(seqname);
</code></pre>

<p>}
{% endhighlight %}</p>

<p>其中maindb是因为项目支持多数据库的缘故，传入参数maindb来判断是否走主库还是地市库。
我不知道这个"1"是怎么来的，我随口冒出一句：能不能不传递maindb,谁知道要传递什么呢?</p>

<p>于是很快冒出"改进"方案，换成一个布尔值，代码变成这样:
{% highlight java %}
public Object getSeqValue(String seqname, boolean isMaindb){</p>

<pre><code>if(isMaindb){
    DbRunContext.setRegion(DbRunContext.MAINDB);
}
// more codes
return XXDao.queryForObject(seqname);
</code></pre>

<p>}
{% endhighlight %}</p>

<p>很显然这不是一个好的解决办法，我从使用者的角度来说，举了下面的例子:
{% highlight java %}
getSeqValue(seqname, true);
getSeqValue(seqname, false);
{% endhighlight %}
单单看上面的调用方式，谁能很清楚的说明分别是什么意思?</p>

<p>很明显，这相当的困难。所以我建议对方法进行重命名，例如
{% highlight java %}
getSeqValueFromMaindb(seqname);
getSeqValue(seqname);
{% endhighlight %}
当然，可以考虑把原来的方法换成私有的，这样避免代码重复而不会对调用者造成困惑。</p>

<h3>迷惑人的参数随处可见</h3>

<p>在我们的代码里边，类似这样的参数困惑随处可见，除了这种布尔值，还有"1"和"0"
这种魔法数字，字符串，因为调用太频繁了，很多人不愿意给他取个好听的名字。</p>

<p>例如区分调用后台逻辑是否起事务，用得太多了，加上老代码就这么用，所以很多同事
没有意识加个IS_TRANSACTION这类的静态变量。看，代码就变成下面的样子：
{% highlight java %}
commonInvoke(operator, cmd, subcmd, "1");
commonInvoke(operator, cmd, subcmd, "0");
{% endhighlight %}</p>

<p>参数这东西，对看代码的人来说没什么特别的帮助，参数越多越迷惑。
当两个方法调用就差一个布尔值不一样的时候，那是相当痛苦的。
所以最好还是从方法名上进行区分，保持代码的可读性。对于接口方法，公用方法，更是应该如此。</p>

<p>{% assign series_list = "improve bitter code" %}
{% include series_list.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[improve bitter code]]></title>
    <link href="http://mccxj.github.com/blog/20120721_improve-bitter-code.html"/>
    <updated>2012-07-21T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/improve-bitter-code</id>
    <content type="html"><![CDATA[<h3>想法</h3>

<p>周五的时候去了趟图书馆，回来的时候已经2点了，又是组织参加每周的代码评审了。
这项活动已经参加了很多次了，但还是经常会遇到相同的问题，即使每天codediff，
也很难避免问题一次次的重复出现。代码基还是不可避免的膨胀，需求变化还是那么的频繁，
人员流动还是那么快，新人还是有那么多不成熟的编码风格。</p>

<p>在这个开发团队里边，也没少唠叨编码规范，codediff也是经常再做，代码评审还是有弄，
但最终的效果，体现在代码上，还远远没有那么乐观。我认为这有好些原因：一方面是历史原因，
代码基庞大，复杂，每天对着这些代码，连好代码是怎样的都没有见过，还能真的无师自通?
另外一方面是各种质量改进活动参与度都不是很高，毕竟目标是完成需求，时间久了热情一点点磨灭，
对这个就更不重视了。</p>

<p>相信很多人看过郑大的代码之丑，里边很多素材就出自我所在的项目组，所以这种代码我也看见不少了，
正因为如此，我觉得我也能写一些相关的内容。在下班坐地铁回来的时候，
我列了一些相关主题，更确信了还是有很多内容可以做文章的。大多数题材来自
项目的代码，自己的想法思路则是来源于平时的实践，工作经历，还有开源代码和各种相关的书籍。</p>

<h3>计划</h3>

<p>整个系列围绕bitter code来说，毕竟维护现有代码是非常重要的工作。这么个系列名称灵感来源于
代码之丑系列和一本叫bitter java的书籍。虽然我觉得代码之丑的名称不是很好，但内容形式会和
这个系列类似，只是会多加一些上下文和背景。文章内容仍然以代码为主线，写出我对代码的改进意见，
至于发布周期，大约是一个星期争取不少于两篇!!</p>

<p>期待吧!!!</p>

<p>{% assign series_list = "improve bitter code" %}
{% include series_list.html %}</p>
]]></content>
  </entry>
  
</feed>
