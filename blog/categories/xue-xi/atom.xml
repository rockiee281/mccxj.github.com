<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 学习 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/xue-xi/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-06-02T22:08:40+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[读书会,爱读书]]></title>
    <link href="http://mccxj.github.com/blog/20130517_reading-share-java-puzzle.html"/>
    <updated>2013-05-17T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/reading-share-java-puzzle</id>
    <content type="html"><![CDATA[<p>话说，很久没有更新博客了，真是惭愧呀。</p>

<p>今天下午，在部门里边小范围举行了一场读书分享会。我把最近读的一本书,java解惑跟大家分享一下。
主要使用了书中的一些范例，跟大家一起学习探讨，分享会下来，大家都觉得挺高兴的。</p>

<p>我的主要目的也达到了，活跃一下大家的气氛，接下来计划每周简单搞一次，或许再弄点吃的，好好享受这个过程。
当然，这个需要持续进行，还少不了更多人的支持，慢慢把范围和影响扩大，逐渐成为一个招牌节目:)</p>

<p>java解惑也是好几年前的书了，很早之前就听过，这次是在地铁上拿电子版在看，基本上我只能答对里边一半左右的谜题，
感觉对于java这么古板的语言，坑都不少，跟何况c++这样的庞然大物? 总体来说，我给这本书评4颗星，推荐级别。</p>

<p>下周的读书会，讲一本java网络编程的入门书籍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习和理解servlet(旧)]]></title>
    <link href="http://mccxj.github.com/blog/20121208_servlet-study-log.html"/>
    <updated>2012-12-08T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/servlet-study-log</id>
    <content type="html"><![CDATA[<p>08年写的笔记，看上去很不是太烂:)</p>

<h2>简单应用服务器</h2>

<p>经常会听到应用服务器的说法，主要作用就是能够根据http请求来分配资源。在java里边，就是跟java.net.*相关的socket编程。
更详细的内容需要查看相关内容。这里只是不想上当受骗，以为是某某魔术来着。</p>

<h2>什么是规范</h2>

<p>为了方便开发，应用服务器开发商只要实现相关的规范，使用者在使用这些api的时候根本不用考虑对应的服务器是怎样的。
简单来说，就是定义好的接口。而servlet和jsp就是这样一类规范。tomcat6.0.18是支持servlet2.5和jsp2.1的规范的。在源码里边实现了这套规范，相关的包是javax.servlet.*.</p>

<h2>学习和理解servlet</h2>

<p>servlet是一套比较简单的规范，单从tomcat的实现代码就可以知道。从可以得到的资料上看，
也没有多少复杂的内容。窃以为从书上就可以获取到基本的内容了，有个感性印象的基础读一遍
api doc就基本ok了。再多的东西，具体的应用实现，查阅cookbook之类的guice。
这部分内容相当重要，是java web最重要的基础</p>

<p>接下去的部分，基本上是api doc和tomcat实现的内容的梳理。即使再怎样，我都要经常翻阅资料，这是免不了的。
可以注意到servlet一共有两个包，javax.servlet和javax.servlet.http,明显就是一个是基础接口，一个是http协议的实现，
从里边的类名也可以看出，http包的类前面基本都加上Http前缀的。先对他们进行更详细的分类，
大概就是各个基础组件(context,request,response,servlet,filter,stream,listener)，还有一系列对应的listener,几个http特殊的东西(session,cookie).下面分别来说，就怕有些乱，请见谅：</p>

<h4>ServletConfig</h4>

<p>servlet初始化的时候，web容器传递的一个servlet configuration object。</p>

<h4>ServletContext</h4>

<p>我们知道，每个jvm里边一个web应用（通常是一个war包，具有特定的部署结构）就对应一个context，
这个接口就是定义了context和servlet容器交互的一些方法。context是web应用全局可见的，因此ServletConfig就有个方法getServletContext来获取对应的context。</p>

<h4>Servlet</h4>

<p>所有的Servlet必须实现Servlet接口。一个servlet是一个跑在web服务器的java程序，用来接受请求，并做出响应，
对应的请求和响应就是ServletRequest和ServletResponse了。这个生命周期主要有三部分，对于一个jvm来说，
servlet初始化的时候会调用init方法，容器负责把ServletConfig作为参数传递给这个方法，这个步骤对于一个生命周期来说只会做一次。
初始化之后，任何请求调用都会调用service方法，而ServletRequest和ServletResponse就作为两个参数传递进去了。
在容器关闭的时候，servlet将会给销毁，这个时候就会调用destroy方法，这个步骤跟init一样，也是调用一次的。
为了方便使用，已经GenericServlet和HttpServlet做了部分的实现，特别是HttpServlet，根据Http请求方法，分发给doGet，doPost等方法，
这就是为什么继承HttpServlet做servlet实现的时候，一般只是覆盖doGet或doPost方法就可以的原因，</p>

<h4>ServletRequest,ServletResponse</h4>

<p>在调用Servlet的service的方法时，会涉及ServletRequest和ServletResponse，这两个object是
由容器负责生成并传递进来的。简单的解释，ServletRequest是用来提供客户端的请求信息的，例如请求方法，参数，ip等等，
而ServletResponse就是用来返回给客户端的响应信息，一般来说，我们会通过getWriter(字符数据)或者getOutputStream(二进制)来输出信息。
当然，character encoding和content type也是放在ServletResponse的，你可以进行改变。一般来说，我们处理浏览器请求，几乎都是http协议，
所以几乎都是HttpServletRequest和HttpServletResponse。</p>

<h4>FilterConfig,Filter，FilterChain</h4>

<p>过滤器，在web.xml经常看到元素，它就是实现Filter的一些类而已。。可以注意到Filter接口跟Servlet有些像，
在初始化的时候，容器传递一个FilterConfig对象作为init方法的参数，而在销毁的时候会调用destroy方法。当有请求过来的时候，容器会拦截符合要求的请求（根据请求路径），
并调用doFilter方法，可以注意到除了平时看到的request和response参数，还有个FilterChain参数。这个对象是由容器负责维护，可以看做是这次请求需要经过的filter链。一般来说
<div class="highlight"><pre><code class="bash">before_filter :dosoming with request and response
chain.doFilter<span class="o">(</span>request,response<span class="o">)</span>;//进入其他Filter
after_filter :dosoming with request and response
</code></pre></div>
上面前后两部分不一定都会存在，大家有机会看看例子就知道了。filter的作用范围很大，一般用来做验证权限，记录日志，响应内容压缩，内容加密，特殊参数过滤，转换编码格式等等</p>

<h4>Cookie,HttpSession</h4>

<p>Http协议是一种无状态协议，所以有必要做点其他东西来保留状态。cookie带有简单信息的东东（key/value对，看起来就像个Map），
用来保存在浏览器的，然后每次请求的时候，又把cookie发送到服务器。可以通过ServletResponse的addCookie方法加入cookie。
需要注意的是，cookie具有一些特殊性，可以设置保留时间，是否加密等等，鉴于安全性考虑，一般只用来对付那些不是很重要的数据。
HttpSession说的是session，他的数据其实是保存在服务器的，服务器根据每个sessionid，保留一份对应的数据，客户端就是根据这个sessionid来作为钥匙的。
这个钥匙也是要像cookie那样传来传去的，这个时候的sessionid一般有两种交互方式，基于cookie（作为cookie的key/value对）
和基于url rewrite（在url后边带上个参数而已），常用的方法：setAttribute,getAttribute（跟ServletRequest的方法差不多）,invalidate等等</p>

<h4>Listener,Event</h4>

<p>经常会在web.xml里边看到元素，对应的类是实现ServletContextListener接口的。其实这类Listener有不少，在servlet2.5规范里边有8个，而且有对应的Event类</p>

<p><strong>ServletContextListener,ServletContextEvent</strong>
这是用来监听servlet context的，是在初始化和销毁的时候会触发相应的事件，并会有个ServletContextEvent对象
参数，通过这个参数的getServletContext方法就可以获取相应的ServletContext对象了。</p>

<p><strong>ServletContextAttributeListener，ServletContextAttributeEvent</strong>
这个也是用来监听servlet context的，关注点是它里边的attribute的改变。一个类如果实现了
这个接口，那么在attribut发生变化的时候，就会触发相应的方法。</p>

<p><strong>ServletRequestListener,ServletRequestEvent,ServletRequestAttributeListener,ServletRequestAttributeEvent</strong>
这些都是类似的，只不过这里是ServletRequest</p>

<p><strong>HttpSessionListener,HttpSessionEvent,HttpSessionAttributeListener,HttpSessionEvent</strong>
类似，就是这两个listener用的是同一个Event</p>

<p><strong>HttpSessionBindingListener,HttpSessionBindingEvent</strong>
一个类如果实现了这个接口，那么在他和session绑定或者解绑的时候就会触发相应的方法。</p>

<p><strong>HttpSessionActivationListener,HttpSessionEvent</strong>
注意这里使用的也是那个Event。此接口处理从一个服务器移动到另一个服务器的会话，貌似是用在分布式环境的。</p>

<p>监听器还是很多类型的，注意区分，貌似需要用到的时候也不是很多，感觉没filter用得多</p>

<h4>RequestDispatcher,SingleThreadModel</h4>

<p>貌似这个dispatcher经常用来做请求转发(forward)或者资源内嵌(include)的工作。可以通过ServletRequest来获得一个转发对象。
使用forward可以确保attribute里边的信息不丢失，实现信息传递。
SingleThreadModel，因为Servlet并非线程安全，所以才有这么个东东来保证一个jvm只有一个线程可以同时访问。具体的看资料，这个东西是不推荐使用的，
理由很简单，性能不好罗。既然非线程安全，那么就要保留servlet的无状态性。。。。</p>

<p><strong>要点：区分各个对象的生命周期和作用</strong></p>

<h4>其他讨论</h4>

<ul>
<li>能否在一个ServletRequest对象中获取ServletConfig对象，为什么?</li>
<li>讨论何时使用context,cookie，session，request传递信息。他们的存活期是怎样的？</li>
<li>SingleThreadModel的弊端和解决办法？</li>
<li>上传文件和提交普通表单的处理方式？如何避免重复sumbit form？</li>
<li>重定向和转发的区别，在servlet的里边的使用方法？</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于分享]]></title>
    <link href="http://mccxj.github.com/blog/20121120_how-to-share.html"/>
    <updated>2012-11-20T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/how-to-share</id>
    <content type="html"><![CDATA[<h2>分享好处多多</h2>

<p>通过做一些分享活动，一方面可以扩大自己的影响力，让更多的人知道你。
另外一方面，可以加深自己对知识的理解，在交流中纠正一些错误的理解。
还可以提高自己的表达能力。可以说，除了需要花时间准备之外，分享对自己来说，几乎是百利而无一害的。</p>

<h2>参与度与氛围</h2>

<p>自己做分享，总是希望有更多的人来参与，并从中营造一个愉悦的氛围，
互惠互利，从中可以学习到更多。但是，经常遇到的事实是，参与的童鞋常常不愿意发言。
一方面是可能是自己不擅长，更多看成是培训，而不是交流活动，害怕犯错。还有就是，
他们没有事先做一些准备，对内容理解不够快，所以也没什么特别的疑问。
我认为，提出一些低级问题，并不是什么丢人的事情，可能是分享人没有照顾到你(经常是一类人)，
如果你不提出来的话，或许分享人会自认为大家都很明白。总之，参与一些分享活动，能全身心
投入，收获会更大。</p>

<h2>敢于分享</h2>

<p>很多童鞋都害怕分享，总是担心自己水平不够，准备不够充分，所以一拖再拖。
以我的经验，分享的内容你刚刚够得着就可以了，因为你准备的过程中，会对自己掌握的内容进行
筛选，收集更多的资料，然后进行浓缩总结，到最后你把它分享给其他人，整个过程下来，就是一次很好的
锻炼机会。不要太担心做不好，即使有些地方自己说不清，但或许经过众人的讨论，理解得就更好了。
还有就是，什么都要计划，给自己的分享计划加个合理的期限吧，少许的压力能让你做得更好。</p>

<h2>节奏与时间</h2>

<p>每次分享的时间不要过长，我就犯过这样的错误，到后面很多人都开始走神了。
还有就是，主题要比较单一，免得铺开太大，不好收缩，影响时间和效果。
时间比较长的话，中间可以适当休息一下。</p>

<h2>想不到的收获</h2>

<p>最近做了一次关于oracle执行计划的分享活动，说实话，我对这个主题不是很熟悉。
但是我觉得这东西很有用，也非常适合团队里的童鞋，所以花了几个星期的时间收集资料，
最后做了这么一个分享活动。经自己讲解了一遍，自己对这些知识加深了理解。更让我想不到的事情就是，
有其他项目组的童鞋遇到了相关的问题，跑来跟我讨论(哥俨然是专家啦)。正因为这样，我才有机会遇到更多现实的问题，
从而促进我对这些东西的理解，如果没有这次分享，有些东西可能就没法用在实践上了。
我想，很多高手也是这么炼成的。:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[improve bitter code: 多掌握一门语言]]></title>
    <link href="http://mccxj.github.com/blog/20120804_improve-bitter-code-7.html"/>
    <updated>2012-08-04T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/improve-bitter-code-7</id>
    <content type="html"><![CDATA[<p><strong>备注: 示例中的代码并不是真实代码的完全拷贝</strong></p>

<h3>语言是有区别的</h3>

<p>语言是有'好坏'之分的，在不同的应用背景下，有些语言就是比其他一些语言更为合适！
语言是有它的设计目的，有些是为了效率(c)，有些是为了快乐编程(ruby)，有些则是了并发做准备(erlang)。
学习不同类型的语言也有助于锻炼编程思维，像c,java,ruby,javascript,erlang都教会了我许多东西。</p>

<p>来到这边之后，主要工作语言是java，但并不是说其他语言没有了用武之地，我一直在寻找使用其他语言的机会。
下面举些例子，来说明一下。由于我以前大量使用ruby语言，的确我也是特别喜欢。
所以例子以ruby为主，但并不是说其他语言没法做到，或许有更好的做法也不一定。</p>

<h5>临时生成xml文件</h5>

<p>前几天维护那边需要我提供一个xml文件，它提供了一组txt数据:每半个小时的登陆及操作统计。
我需要生成一个xml，我不熟悉excel操作(花了几分钟尝试了一下)，所以我选择使用脚本来生成。
脚本只花了一分钟,比我预想得还要顺利。
<div class="highlight"><pre><code class="ruby"><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;a.xml&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
  <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;a.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">ff</span><span class="o">|&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;ff.readlines.each_with_index do |l, i|</span>
<span class="sr">  dl, cz = l.split(&#39; &#39;)</span>
<span class="sr">  f &amp;lt;&amp;lt; &quot;&amp;lt;data&amp;gt;&amp;lt;seq&amp;gt;</span><span class="si">#{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="sr">&amp;lt;/se</span><span class="n">q</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">czvalue</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="c1">#{cz}&amp;lt;/czvalue&amp;gt;&amp;lt;dlvalue&amp;gt;#{dl}&amp;lt;/dlvalue&amp;gt;&amp;lt;/data&amp;gt;&quot;</span>
<span class="k">end</span>
<span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
对于这种一次性的文本处理，java真是太繁琐了，没有任何优势可言。</p>

<h5>定位数据问题</h5>

<p>曾经有次上版本之后发现一个菜单树不能使用。通过代码定位应该是菜单出现循环依赖了(菜单在表中是父子关系的)。
同事也把生产的数据拿过来了。数据格式类似下面的，第一列是菜单id，第二列是父菜单id，还有其他的数据列。
<div class="highlight"><pre><code class="java"><span class="n">ITEM1</span> <span class="n">ITEM2</span> <span class="n">OTHERS</span><span class="o">...</span>
<span class="n">ITEM2</span> <span class="n">ITEM3</span> <span class="n">OTHERS</span><span class="o">...</span>
<span class="n">ITEM4</span> <span class="n">ITEM2</span> <span class="n">OTHERS</span><span class="o">...</span>
<span class="n">ITEM5</span> <span class="n">ITEM3</span> <span class="n">OTHERS</span><span class="o">...</span>
</code></pre></div>
问题已经变成：父子是否出现循环。当时我用了几分钟写了一段脚本来找到出现循环的菜单项，最后发现是其他项目组增加的菜单有问题。</p>

<h5>传数据的偷懒方法</h5>

<p>以前还是老邮箱的时候，由于网络隔离，需要把测试相关的东西通过邮箱发到测试环境去。
我每次都是这么弄的：通过网页登录邮箱，新建邮件，把已经打包加密好的文件作为附件添加，保存为草稿，退出。
次数多了，真的很无聊，有时候一天要弄好几次。</p>

<p>我知道有种测试方式叫自动化测试，所以我用watir(一个用ruby写的自动化测试框架)模拟了整个过程。后来我把这个脚本调用集成到菜单右键上，
只需要把需要上传的文件选中，再触发一个右键菜单。打包加密，上传文件就搞定了。那时候的感觉就是，世界清净了。</p>

<h5>实现codediff应用</h5>

<p>有些框架工具有非常高的生产效率，ruby on rails就是其中一个。在项目中进行codediff使用的工具，主要是通过这个框架开发的。
说真的，这么一个东西，用java实现也不是什么难事。但对我来说，1k行的ruby代码量，sql一行也没有写，维护上要省心得多。</p>

<p>只要能够对项目有意义，谁会关心我是用什么来实现的呢?</p>

<h5>部署应用</h5>

<p>这是个cmo比较熟悉的领域。大多数情况下，我们会选择bash等shell工具。
不过我在开发codediff工具的时候，我想在本地直接就把应用部署到开发环境上去。</p>

<p>windows的bat很烂，shell等有比较多限制，所以我又选择了脚本语言。
使用perl,ruby等脚本来做管理脚本并不少见，我这里选择一个好几年前写的脚本作为例子：
<div class="highlight"><pre><code class="ruby"><span class="n">cmd</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">shell</span><span class="o">|</span>
  <span class="n">shell</span><span class="o">.</span><span class="n">cd</span><span class="p">(</span><span class="s2">&quot;/opt/xxx&quot;</span><span class="p">)</span>
  <span class="nb">print</span> <span class="s2">&quot;current directory:&quot;</span><span class="p">,</span><span class="n">shell</span><span class="o">.</span><span class="n">pwd</span><span class="o">.</span><span class="n">stdout</span>
  <span class="nb">print</span> <span class="n">shell</span><span class="o">.</span><span class="n">sh</span><span class="p">(</span><span class="s2">&quot;/opt/getupdate.sh&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">stdout</span>
  <span class="n">shell</span><span class="o">.</span><span class="n">exit</span>
<span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;p&gt;Net::SSH.start(&#39;192.168.1.32&#39;, :username =&gt; &#39;root&#39;, :password=&gt;&#39;psword&#39;) do |session|</span>
<span class="sr">  shell = session.shell.sync</span>
<span class="sr">  cmd.call(shell)</span>
<span class="sr">end</span>
</code></pre></div></p>

<p>上面的例子比较简单，现实的例子是本地打包，通过ftp上传，解压发布，重启服务器，每个步骤都带交互功能。
脚本语言和普通shell相比，具有完整语言和跨平台的优势，用来做系统管理是一个不错的选择。</p>

<h3>多掌握一门语言</h3>

<p>整篇内容没有涉及编程技巧上的东西，但这却是我最想表达的内容。
在这里，我用Martin Fowler中国行的时候，<a href="http://www.ituring.com.cn/article/2083">图灵社区对他的采访内容</a>来结束，
里边有关于学习编程语言建议的内容。</p>

<p><strong><em>图灵社区：您曾经建议过程序员应该每年学习一门编程语言。</em></strong></p>

<p><strong><em>M</em></strong>：这实际上是Pragmatic Programmers提出的建议，是他们出版的书中的一条建议，我本人很赞同。我认为应该有意地学习一些新的语言，特别是那些和你所熟知的语言的运作方式相差甚远的语言，所以不要在相似的语言上浪费时间。如果你是一位Java程序员，那么C#对于你来说就太过熟悉了，你需要学习一些很不同的语言，比如说Lisp，或者Clojure；如果你是一位Lisp程序员，你也不需要学Clojure，因为那就是另一种Lisp而已。总之你应该尝试一些很不同的语言。</p>

<p>


<h2>"improve bitter code"系列文章:</h2>
<ul>
 
  
  <li><a href="/blog/20120721_improve-bitter-code.html">2012-07-21 improve bitter code</a></li>
  
 
  
  <li><a href="/blog/20120724_improve-bitter-code-1.html">2012-07-24 improve bitter code: 迷惑的boolean参数</a></li>
  
 
  
  <li><a href="/blog/20120724_improve-bitter-code-2.html">2012-07-24 improve bitter code: 更友好的链式写法</a></li>
  
 
  
  <li><a href="/blog/20120728_improve-bitter-code-3.html">2012-07-28 improve bitter code: 看不懂的正则表达式</a></li>
  
 
  
  <li><a href="/blog/20120729_improve-bitter-code-4.html">2012-07-29 improve bitter code: '不可避免'的重复</a></li>
  
 
  
  <li><a href="/blog/20120729_improve-bitter-code-5.html">2012-07-29 improve bitter code: 拘泥于单出口方法</a></li>
  
 
  
  <li><a href="/blog/20120731_improve-bitter-code-6.html">2012-07-31 improve bitter code: 对付魔鬼数字</a></li>
  
 
  
  <li><a href="/blog/20120804_improve-bitter-code-7.html">2012-08-04 improve bitter code: 多掌握一门语言</a></li>
  
 
  
  <li><a href="/blog/20120807_improve-bitter-code-8.html">2012-08-07 improve bitter code: 判空的处理</a></li>
  
 
  
  <li><a href="/blog/20120815_improve-bitter-code-9.html">2012-08-15 improve bitter code: 没有行为的封装</a></li>
  

</ul>



</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[improve bitter code]]></title>
    <link href="http://mccxj.github.com/blog/20120721_improve-bitter-code.html"/>
    <updated>2012-07-21T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/improve-bitter-code</id>
    <content type="html"><![CDATA[<h3>想法</h3>

<p>周五的时候去了趟图书馆，回来的时候已经2点了，又是组织参加每周的代码评审了。
这项活动已经参加了很多次了，但还是经常会遇到相同的问题，即使每天codediff，
也很难避免问题一次次的重复出现。代码基还是不可避免的膨胀，需求变化还是那么的频繁，
人员流动还是那么快，新人还是有那么多不成熟的编码风格。</p>

<p>在这个开发团队里边，也没少唠叨编码规范，codediff也是经常再做，代码评审还是有弄，
但最终的效果，体现在代码上，还远远没有那么乐观。我认为这有好些原因：一方面是历史原因，
代码基庞大，复杂，每天对着这些代码，连好代码是怎样的都没有见过，还能真的无师自通?
另外一方面是各种质量改进活动参与度都不是很高，毕竟目标是完成需求，时间久了热情一点点磨灭，
对这个就更不重视了。</p>

<p>相信很多人看过郑大的代码之丑，里边很多素材就出自我所在的项目组，所以这种代码我也看见不少了，
正因为如此，我觉得我也能写一些相关的内容。在下班坐地铁回来的时候，
我列了一些相关主题，更确信了还是有很多内容可以做文章的。大多数题材来自
项目的代码，自己的想法思路则是来源于平时的实践，工作经历，还有开源代码和各种相关的书籍。</p>

<h3>计划</h3>

<p>整个系列围绕bitter code来说，毕竟维护现有代码是非常重要的工作。这么个系列名称灵感来源于
代码之丑系列和一本叫bitter java的书籍。虽然我觉得代码之丑的名称不是很好，但内容形式会和
这个系列类似，只是会多加一些上下文和背景。文章内容仍然以代码为主线，写出我对代码的改进意见，
至于发布周期，大约是一个星期争取不少于两篇!!</p>

<p>期待吧!!!</p>

<p>


<h2>"improve bitter code"系列文章:</h2>
<ul>
 
  
  <li><a href="/blog/20120721_improve-bitter-code.html">2012-07-21 improve bitter code</a></li>
  
 
  
  <li><a href="/blog/20120724_improve-bitter-code-1.html">2012-07-24 improve bitter code: 迷惑的boolean参数</a></li>
  
 
  
  <li><a href="/blog/20120724_improve-bitter-code-2.html">2012-07-24 improve bitter code: 更友好的链式写法</a></li>
  
 
  
  <li><a href="/blog/20120728_improve-bitter-code-3.html">2012-07-28 improve bitter code: 看不懂的正则表达式</a></li>
  
 
  
  <li><a href="/blog/20120729_improve-bitter-code-4.html">2012-07-29 improve bitter code: '不可避免'的重复</a></li>
  
 
  
  <li><a href="/blog/20120729_improve-bitter-code-5.html">2012-07-29 improve bitter code: 拘泥于单出口方法</a></li>
  
 
  
  <li><a href="/blog/20120731_improve-bitter-code-6.html">2012-07-31 improve bitter code: 对付魔鬼数字</a></li>
  
 
  
  <li><a href="/blog/20120804_improve-bitter-code-7.html">2012-08-04 improve bitter code: 多掌握一门语言</a></li>
  
 
  
  <li><a href="/blog/20120807_improve-bitter-code-8.html">2012-08-07 improve bitter code: 判空的处理</a></li>
  
 
  
  <li><a href="/blog/20120815_improve-bitter-code-9.html">2012-08-15 improve bitter code: 没有行为的封装</a></li>
  

</ul>



</p>
]]></content>
  </entry>
  
</feed>
