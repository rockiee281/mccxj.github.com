<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: trove | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/trove/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-12-22T09:50:22+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[性能优化:Trove集合库]]></title>
    <link href="http://mccxj.github.com/blog/20130602_introduce-to-trove.html"/>
    <updated>2013-06-02T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/introduce-to-trove</id>
    <content type="html"><![CDATA[<h2>1 初见Trove</h2>

<p>昨天在<a href="http://news.dbanotes.net/news">Startup News</a>上看到一篇文章:<a href="http://blog.jobbole.com/40666/">优化技巧分享：把内存消耗降低至原来的1/20</a>。里边提到了一个案例，Java应用中如何降低内存消耗，总结了他的优化过程:</p>

<ul>
<li>开始时,存放1.3M个Person对象，消耗堆空间1.5GB</li>
<li>修改为java.util.HashMap&lt;Long, Person>进行缓存,从1.5GB降低为214MB</li>
<li>修改HashMap为Trove的TLongObjectHashMap<Person>，从214MB降低为143MB</li>
<li>优化Person内部结构,减少重复字段,从143MB降低为93MB</li>
<li>开启64位JDK的XX:UseCompressedOops参数进行指针压缩,从93MB降低为73MB</li>
</ul>


<p>优化经常得针对具体的场景、数据特性来优化，上述提到的<a href="http://trove.starlight-systems.com/">Trove</a>集合库就是这么一个典型例子,它针对的是JDK集合类中处理原生类型的场景。</p>

<h2>2 使用Trove</h2>

<ul>
<li>如果使用Maven的话,可使用下面的配置</li>
</ul>


<p>``` xml
<dependency></p>

<pre><code>&lt;groupId&gt;net.sf.trove4j&lt;/groupId&gt;
&lt;artifactId&gt;trove4j&lt;/artifactId&gt;
&lt;version&gt;3.0.3&lt;/version&gt;
</code></pre>

<p></dependency>
```
* 常用方法和JDK集合类是一样的，方便迁移</p>

<p><code>java
TIntObjectMap&lt;String&gt; ints = new TIntObjectHashMap&lt;String&gt;();
ints.put(100, "John");
ints.put(101, "Tom");
System.out.println(ints.get(100));
</code></p>

<p>Trove相当于把JDK集合类都针对原生类型处理了一遍，例如int，常见的类有
TIntList、TIntObjectMap<V>、TObjectIntMap<K>、TIntSet，可想而知，<strong>维护Trove的工作量是挺大的</strong>。</p>

<p>Trove还提供了开放寻址法的Map,Set,LinkedList实现,可以参考<a href="http://www.onjava.com/pub/a/onjava/2002/06/12/trove.html?page=2">Enhance Collection Performance with this Treasure Trove</a>的做法,类似于:</p>

<p>``` java
public class CollectionFactory {</p>

<pre><code>static boolean useTrove = true;

/**
 *  Return a hashmap based on the properties
 */
public static Map getHashMap() {
    if ( useTrove ) return new THashMap();
    else            return new HashMap();
}

/**
 *  Return a hashset based on the properties
 */
public static Set getHashSet() {
    if ( useTrove ) return new THashSet();
    else            return new HashSet();
}

/**
 *  Return a linkedlist based on the properties
 */
public static List getLinkedList() {
    if ( useTrove ) return new TLinkedList();
    else            return new LinkedList();
}
</code></pre>

<p>}
```</p>

<ul>
<li>迭代集合中的元素</li>
</ul>


<p><strong>Trove不推荐JDK的entryXX的做法，而是采用了forEach的回调方式</strong>。
代码显得更好看些，另外内存方面也有优势，因为使用entryXX的做法，需要创建一个新的数组。</p>

<p>``` java
TIntObjectMap<String> ints = new TIntObjectHashMap<String>();
ints.put(100, "John");
ints.put(101, "Tom");
ints.forEachEntry(new TIntObjectProcedure<String>() {</p>

<pre><code>public boolean execute(int a, String b) {
    System.out.println("key: " + a + ", val: " + b);
    return true;
}
</code></pre>

<p>});
ints.forEachKey(new TIntProcedure() {</p>

<pre><code>public boolean execute(int value) {
    System.out.println("key: " + value);
    return true;
}
</code></pre>

<p>});
ints.forEachValue(new TObjectProcedure<String>() {</p>

<pre><code>public boolean execute(String object) {
    System.out.println("val: " + object);
    return true;
}
</code></pre>

<p>});
```</p>

<ul>
<li>自定义Hash策略</li>
</ul>


<p>我们知道，在JDK集合类里边，有时候是没法自定义Hash策略的，例如String。
<strong>不过Trove提供了自定义Hash策略的功能，让你可以根据数据特性进行优化</strong>。</p>

<p>``` java
public static void main(String[] args) {</p>

<pre><code>char[] foo = new char[]{'a', 'b', 'c'};
char[] bar = new char[]{'a', 'b', 'c'};
TCustomHashMap&lt;char[], String&gt; ch = new TCustomHashMap&lt;char[], String&gt;(new CharArrayStrategy());
ch.put(foo, "John");
ch.put(bar, "Tom");
</code></pre>

<p>}</p>

<p>class CharArrayStrategy implements HashingStrategy&lt;char[]> {</p>

<pre><code>public int computeHashCode(char[] c) {
    // use the shift-add-xor class of string hashing functions
    // cf. Ramakrishna and Zobel, "Performance in Practice
    // of String Hashing Functions"
    int h = 31; // seed chosen at random
    for (int i = 0; i &lt; c.length; i++) { // could skip invariants
        h = h ^ ((h &lt;&lt; 5) + (h &gt;&gt; 2) + c[i]); // L=5, R=2 works well for
                                              // ASCII input
    }
    return h;
}

public boolean equals(char[] c1, char[] c2) {
    if (c1.length != c2.length) { // could drop this check for fixed-length
                                  // keys
        return false;
    }
    for (int i = 0, len = c1.length; i &lt; len; i++) { // could skip
                                                     // invariants
        if (c1[i] != c2[i]) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p>}
```</p>

<h2>3 Trove内幕</h2>

<p>Trove是以减少内存消耗为主要目的的，同时也要保持性能。我们这里简单描述一下Trove的实现内幕。
这里有有另外一篇文章可以参考：<a href="http://www.ibm.com/developerworks/cn/java/j-perf09284.html">性能观察: Trove 集合类</a></p>

<ul>
<li>直接使用原生类型,而不是包装类型</li>
</ul>


<p>JDK5的自动封箱机制，让我们可以暂时忽略原生类型和包准类型的区别。自动封箱机制只是一种语法糖，实际上并没有提高效率。
直接使用原生类型替代包装类型，明显可以占用更小的内存、运行起来也更有效率。对于基本类型的集合组合，Trove都提供了
等价的集合类。</p>

<ul>
<li>使用开放寻址法，而不是链地址法</li>
</ul>


<p>大多数的JDK集合类都是采用链地址法实现的，它需要一个地址表，并且元素之间需要链表结点，而Trove采用开放寻址法，
虽然需要保持足够的空闲位置(装载因子小于0.5),但因为不需要链表结点，所以总体上内存占用要更少，性能还要更快一些。</p>

<ul>
<li>HashSet不再通过内置HashMap实现</li>
</ul>


<p>JDK的HashSet是通过内置一个HashSet来实现的，所以白白浪费了value的空间。
Trove提供的THashSet和其他基本类型的HashSet,都不再采用这种方式，直接使用开放地址存储。</p>

<ul>
<li>采用素数长度大小的数组</li>
</ul>


<p>为了最大程度避免hash冲突，除了保持较小的装载因子，还采用了素数长度大小的数组。具体见gnu.trove.impl.PrimeFinder</p>

<ul>
<li>采用代码生成进行维护</li>
</ul>


<p>虽然这个和性能没什么关系。但是我们也知道要维护这么多的原生类型集合类，重复的逻辑多但没法重用，是个很纠结的事情。
Trove采用代码模板，生成大量的类，通过这种方式，可以大大减少维护的工作量。</p>

<h2>4 总结</h2>

<p>JDK作为通用集合类，大多数情况下我们还是会优先选择的。不过，在一些性能敏感的地方，或者Trove可以提供更好的选择。
作为靠谱的java开发人员，Trove应该像apache commons、google guava那样，存放在你的工具箱里边。</p>
]]></content>
  </entry>
  
</feed>
