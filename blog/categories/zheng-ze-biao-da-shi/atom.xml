<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 正则表达式 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/zheng-ze-biao-da-shi/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2013-06-02T22:01:56+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[improve bitter code: 看不懂的正则表达式]]></title>
    <link href="http://mccxj.github.com/blog/20120728_improve-bitter-code-3.html"/>
    <updated>2012-07-28T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/improve-bitter-code-3</id>
    <content type="html"><![CDATA[<p><strong>备注: 示例中的代码并不是真实代码的完全拷贝</strong></p>

<h3>偶然的发现</h3>

<p>今天好奇浏览了一下N项目的代码变更历史，发现有人提交了一段关于校验文件格式的代码。
其中包括一段校验日期格式的java代码。代码是这样的：
<div class="highlight"><pre><code class="java"><span class="n">String</span> <span class="n">validDateStr</span> <span class="o">=</span> <span class="c1">// read from file lines</span>
<span class="n">String</span> <span class="n">regex</span> <span class="o">=</span> <span class="s">&quot;(([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})(((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)(0[1-9]|[12][0-9]|30))|(02(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))0229)&quot;</span><span class="o">;</span>
<span class="k">if</span><span class="o">(</span><span class="n">validDateStr</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="n">regex</span><span class="o">)){&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// do something</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</code></pre></div></p>

<p>看到这个正则表达式，我立马纠结了，这个正则表达式不知是什么意思。
虽然前几天写代码的同事来问过怎么写校验日期的正则，我当时比较忙，叫他找找有没有现成的。
这次看到这个正则，还是被雷了一把。</p>

<p>于是我问了一下，原来这个正则是校验日期格式，不过加了闰年的判断，所以变得相当复杂。
我晚上还去搜了一下，大概是出自<a href="http://www.cnblogs.com/mgod/archive/2007/04/26/728628.html">这里</a>的吧！不同的是文中判断的是YYYY-MM-DD的格式，而同事的代码
是判断YYYYMMDD的格式，显得更为难懂。</p>

<h3>保持代码的可读性、可维护性</h3>

<p>对于这种拿来的复杂代码，的确很cool，不过即使今天你看懂了，别人不一定看得懂，也难保过些日子自己也看不懂了。</p>

<p>所以通常需要一些保持代码可读性、可维护性的手段：
1. 加多几段注释,或者把来源url标注一下，就像有人喜欢标注那个需求一样。
2. 把正则弄成常量，并把验证方法封装起来，只需调用method就可以了。
3. 选择另外一种比较清晰的实现方式, another way, 或许有惊喜。</p>

<p>应该说，这几种情况都应该考虑一下，例如对于上面的例子来说，要使用这么复杂的正则，加上一些简单的注释
是相当有必要的，至少要说明你是想验证什么样的格式。更进一步，封装到方法里边去，例如
<div class="highlight"><pre><code class="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isStrictYYYYMMDD</span><span class="o">(</span><span class="n">String</span> <span class="n">datestr</span><span class="o">){&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">return</span> <span class="n">datestr</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="n">STRICT_YYYYMMDD_REGEX</span><span class="o">);</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</code></pre></div>
不过这里有个缺点，只能校验一种日期格式，因为日期格式不像邮箱地址，它的形式多样，这样处理能得到的收益并不是很高。
如果我们可以传递校验日期的格式就更好了。</p>

<h3>换个实现方式</h3>

<p>换个思路，如果不使用正则表达式会怎样，例如<a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a>就提供了严格验证的格式，示例代码如下：
<div class="highlight"><pre><code class="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isStrictYYYYMMDD</span><span class="o">(</span><span class="n">String</span> <span class="n">datestr</span><span class="o">){&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">SimpleDateFormat</span> <span class="n">format</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleDateFormat</span><span class="o">(</span><span class="s">&quot;yyyyMMdd&quot;</span><span class="o">);</span>  
<span class="c1">//设置为严格验证模式</span>
<span class="n">format</span><span class="o">.</span><span class="na">setLenient</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="k">try</span><span class="o">{</span>
    <span class="n">format</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ParseException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ignore exeeption</span>
<span class="o">}</span>
<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</code></pre></div>
如果没有设置为严格验证模式的话，20090230这种日期就会变成20090302。</p>

<p>相对于上面正则的方式来说，代码是多了几行，但是因为格式可以变，灵活性有所提高，代码也容易理解了。
另外一方面，由于SimpleDateFormat非线程安全，必须每次都定义一个，在多次处理的情况下显得有些多余。
当然有个折中的方法就是由客户端代码构造format作为传输传递，这样做还有个好处就是，验证日期格式的方法完全就是通用的。</p>

<p>例如，我们可以提供下面的api和调用方式:
<div class="highlight"><pre><code class="java"><span class="c1">//client</span>
<span class="n">SimpleDateFormat</span> <span class="n">format</span> <span class="o">=</span> <span class="c1">// 由客户端代码构建format</span>
<span class="kt">boolean</span> <span class="n">isDate</span> <span class="o">=</span> <span class="n">DateUtil</span><span class="o">.</span><span class="na">isDateFormat</span><span class="o">(</span><span class="n">datestr</span><span class="o">,</span> <span class="n">format</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//DateUtil api</span>
<span class="kt">boolean</span> <span class="nf">isDateFormat</span><span class="o">(</span><span class="n">String</span> <span class="n">datestr</span><span class="o">,</span> <span class="n">SimpleDateFormat</span> <span class="n">format</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="nf">isDateFormat</span><span class="o">(</span><span class="n">String</span> <span class="n">datestr</span><span class="o">,</span> <span class="n">String</span> <span class="n">formatstr</span><span class="o">);</span><span class="c1">//单次调用</span>
<span class="kt">boolean</span> <span class="nf">isStrictDateFormat</span><span class="o">(</span><span class="n">String</span> <span class="n">datestr</span><span class="o">,</span> <span class="n">String</span> <span class="n">formatstr</span><span class="o">);</span><span class="c1">//单次使用,用于严格处理</span>
</code></pre></div></p>

<p>在不改变接口的情况下，最初的代码可以调整成以下形式
<div class="highlight"><pre><code class="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isStrictYYYYMMDD</span><span class="o">(</span><span class="n">String</span> <span class="n">datestr</span><span class="o">){&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">return</span> <span class="n">isStrictDateFormat</span><span class="o">(</span><span class="n">datestr</span><span class="o">,</span> <span class="n">DateUtil</span><span class="o">.</span><span class="na">YYYYMMDD</span><span class="o">);</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</code></pre></div></p>

<h3>总结</h3>

<ol>
<li>隐藏某些复杂的细节是必要的，提供的接口要simple, clear。</li>
<li>封装有助于焦距局部代码，即使要更换实现方式，也更加easy。</li>
<li>可以提供通用可定制接口和常用特殊化接口,方便client调用。</li>
<li><a href="http://commons.apache.org/lang/api-2.5/org/apache/commons/lang/time/DateUtils.html">commons-lang</a>和<a href="http://joda-time.sourceforge.net/">joda-time</a>开源库提供了非常成熟的解决方案。</li>
</ol>


<p>


<h2>"improve bitter code"系列文章:</h2>
<ul>
 
  
  <li><a href="/blog/20120721_improve-bitter-code.html">2012-07-21 improve bitter code</a></li>
  
 
  
  <li><a href="/blog/20120724_improve-bitter-code-1.html">2012-07-24 improve bitter code: 迷惑的boolean参数</a></li>
  
 
  
  <li><a href="/blog/20120724_improve-bitter-code-2.html">2012-07-24 improve bitter code: 更友好的链式写法</a></li>
  
 
  
  <li><a href="/blog/20120728_improve-bitter-code-3.html">2012-07-28 improve bitter code: 看不懂的正则表达式</a></li>
  
 
  
  <li><a href="/blog/20120729_improve-bitter-code-4.html">2012-07-29 improve bitter code: '不可避免'的重复</a></li>
  
 
  
  <li><a href="/blog/20120729_improve-bitter-code-5.html">2012-07-29 improve bitter code: 拘泥于单出口方法</a></li>
  
 
  
  <li><a href="/blog/20120731_improve-bitter-code-6.html">2012-07-31 improve bitter code: 对付魔鬼数字</a></li>
  
 
  
  <li><a href="/blog/20120804_improve-bitter-code-7.html">2012-08-04 improve bitter code: 多掌握一门语言</a></li>
  
 
  
  <li><a href="/blog/20120807_improve-bitter-code-8.html">2012-08-07 improve bitter code: 判空的处理</a></li>
  
 
  
  <li><a href="/blog/20120815_improve-bitter-code-9.html">2012-08-15 improve bitter code: 没有行为的封装</a></li>
  

</ul>



</p>
]]></content>
  </entry>
  
</feed>
