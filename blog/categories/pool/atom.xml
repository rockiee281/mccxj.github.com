<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: pool | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/pool/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2014-01-19T17:43:34+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[带平衡的对象池设计]]></title>
    <link href="http://mccxj.github.com/blog/20130630_object-balance-pool.html"/>
    <updated>2013-06-30T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/object-balance-pool</id>
    <content type="html"><![CDATA[<p>最近有个需求，是关于一个Socket连接池的功能改造，要求实现下面的需求:</p>

<ol>
<li>可配置多个服务器地址</li>
<li>服务器地址可以配置权重(比如3:2:1)</li>
<li>连接池可以设置最小连接和最大连接</li>
<li>某服务器从崩溃中恢复后，连接池中的连接数可以自动恢复到服务器之间的权重比。</li>
<li>连接可设置最大空闲释放时间</li>
</ol>


<p>一开始有同事自定义了一个链表来做取数和归还的操作，在线程安全方面操作感觉还是有点麻烦。
后来我采用PriorityBlockingQueue来实现，其实就是内部变成了堆的结构。见下面的图:</p>

<p><img src="/assets/images/2013/pool/1.png" alt="数据结构" /></p>

<p><img src="/assets/images/2013/pool/2.png" alt="类图" /></p>

<p><img src="/assets/images/2013/pool/3.png" alt="状态图" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探Java字符串]]></title>
    <link href="http://mccxj.github.com/blog/20130615_java-string-constant-pool.html"/>
    <updated>2013-06-15T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/java-string-constant-pool</id>
    <content type="html"><![CDATA[<h2>String印象</h2>

<p>String是java中的无处不在的类，使用也很简单。初学java，就已经有字符串是不可变的盖棺定论，解释通常是:它是final的。</p>

<p>不过，String是有字面量这一说法的，这是其他类型所没有的特性(除原生类型)。另外，java中也有字符串常量池这个说法，用来存储字符串字面量，不是在堆上，而是在方法区里边存在的。</p>

<h2>字面量和常量池初探</h2>

<p>字符串对象内部是用字符数组存储的，那么看下面的例子:</p>

<p><code>java
String m = "hello,world";
String n = "hello,world";
String u = new String(m);
String v = new String("hello,world");
</code></p>

<p>这些语句会发生什么事情? 大概是这样的:</p>

<ol>
<li>会分配一个11长度的char数组，并在常量池分配一个由这个char数组组成的字符串，然后由m去引用这个字符串。</li>
<li>用n去引用常量池里边的字符串，所以和n引用的是同一个对象。</li>
<li>生成一个新的字符串，但内部的字符数组引用着m内部的字符数组。</li>
<li>同样会生成一个新的字符串，但内部的字符数组引用常量池里边的字符串内部的字符数组，意思是和u是同样的字符数组。</li>
</ol>


<p>如果我们使用一个图来表示的话，情况就大概是这样的(使用虚线只是表示两者其实没什么特别的关系):</p>

<p><img src="/assets/images/2013/string/string1.png" alt="对象在内存中的布局" /></p>

<p>结论就是,m和n是同一个对象，但m,u,v都是不同的对象，但都使用了同样的字符数组，并且用equal判断的话也会返回true。</p>

<p>我们可以使用反射修改字符数组来验证一下效果，可以试试下面的测试代码:</p>

<p>``` java
@Test
public void test1() throws Exception {</p>

<pre><code>String m = "hello,world";
String n = "hello,world";
String u = new String(m);
String v = new String("hello,world");

Field f = m.getClass().getDeclaredField("value");
f.setAccessible(true);
char[] cs = (char[]) f.get(m);
cs[0] = 'H';

String p = "Hello,world";
Assert.assertEquals(p, m);
Assert.assertEquals(p, n);
Assert.assertEquals(p, u);
Assert.assertEquals(p, v);
</code></pre>

<p>}
```</p>

<p>从上面的例子可以看到，经常说的字符串是不可变的，其实和其他的final类还是没什么区别，还是引用不可变的意思。
虽然String类不开放value，但同样是可以通过反射进行修改，只是通常没人这么做而已。
即使是涉及"修改"的方法，都是通过产生一个新的字符串对象来实现的，例如replace、toLower、concat等。
这样做的好处就是让字符串是一个状态不可变类，在多线程操作时没有后顾之忧。</p>

<p>当然，在字符串修改的时候，会产生一个新的对象，如果执行很频繁，就会导致大量对象的创建，性能问题也就随之而来了。
为了应付这个问题，通常我们会采用StringBuffer或StringBuilder类来处理。</p>

<p>另外，字符串常量通常是在编译的时候就确定好的，定义在类的方法区里边，也就是说，不同的类，即使用了同样的字符串，
还是属于不同的对象。所以才需要<strong>通过引用字符串常量来减少相同的字符串的数量</strong>。可以通过下面的代码来测试一下：</p>

<p>``` java
class A {</p>

<pre><code>public void print() {
    System.out.println("hello");
}
</code></pre>

<p>}</p>

<p>class B {</p>

<pre><code>public void print() {
    String s = "hello";
    // 修改s的第一个字符为H
    System.out.println("hello"); // 输出Hello
    new A().print(); // 输出hello
}
</code></pre>

<p>}
```</p>

<h2>字符串操作细节</h2>

<p>String类内部处理有个字符数组之外，还使用偏移位置offset和长度count，
通过offset和count来确定字符数组的一部分，这部分才是这个字符串的真正的内容。
例如，有substring这个常用方法，看下面的例子:</p>

<p><code>java
String m = "hello,world";
String u = m.substring(2,10);
String v = u.substring(4,7);
</code></p>

<p>按照上面的说法，m,n的数据结构就如下图所示:</p>

<p><img src="/assets/images/2013/string/string2.png" alt="substring在内存中的布局" /></p>

<p>可以发现，m,n,v是三个不同的字符串对象，但引用的value数组其实是同一个。
同样可以通过上述反射的代码进行验证，这里就不详述了。</p>

<p>但字符串操作时，可能需要修改原来的字符串数组内容或者原数组没法容纳的时候，就会使用另外一个新的数组，例如replace,concat,+等操作。另外，oracle的JDK实现中，String的构造方法，对于字符串参数只是引用部分字符数组的情况(count小于字符数组长度)，采用的是拷贝新数组的方式，是比较特别的，不过这个构造方法也没什么机会使用到。</p>

<p>例如下面的代码:</p>

<p><code>java
String m = "hello,";
String u = m.concat("world");
String v = new String(m.substring(0,2));
</code></p>

<p>得到的结构图如下:</p>

<p><img src="/assets/images/2013/string/string3.png" alt="新字符数组在内存中的布局" /></p>

<p>可以发现，m,u,v内部的字符数组并不是同一个，有兴趣可以试验一下。</p>

<h2>常量池中字符串的产生</h2>

<p>常量池中的字符串通常是通过字面量的方式产生的，就像上述m语句那样。
并且他们是在编译的时候就准备好了，类加载的时候，顺便就在常量池生成。</p>

<p>可以通过javap命令检查一下class的字节码，可以发现下面的高亮部分(以上面代码为例):</p>

<p>``` diff
 javap -v StringTest</p>

<p> Compiled from "StringTest.java"
 public class com.github.mccxj.StringTest extends java.lang.Object
   SourceFile: "StringTest.java"
   minor version: 0
   major version: 50
   Constant pool:
 const #1 = Method       #9.#28; //  java/lang/Object."<init>":()V
+ const #2 = String       #29;    //  hello,
+ const #3 = String       #30;    //  world
 ...
+ const #46 = Asciz       hello,;
+ const #47 = Asciz       world;
 ...
```</p>

<p>大家不知有没有发现，上面的图中，u和v的字符数组没有被常量池里边的字符串引用到。
原因就是这些字符串(字符数组)都是运行时生成的，而常量池里边的字符串和字符数组是完整对应上的(count等于数组长度)。</p>

<p>即使是字符串的内容是一样的，都不能保证是同一个字符串数组。例如下面的代码:</p>

<p><code>java
String m = "hello,world";
String u = m + ".";
String v = "hello,world.";
</code></p>

<p>u和v虽然是一样内容的字符串，但内部的字符数组不是同一个。画成图的话就是这样的:</p>

<p><img src="/assets/images/2013/string/string4.png" alt="不同字符数组在内存中的布局" /></p>

<p>另外有一点，如果让m声明为final，你就会发现u和v变成是同一个对象。画成图的话就是这样的:</p>

<p><img src="/assets/images/2013/string/string5.png" alt="u和v在内存中的布局" /></p>

<p>这应该怎么解释的？这其实都是编译器搞的鬼，因为m是final的，
u直接被编译成"hello,world."了，如果使用javap查看的话，会发现下面一段逻辑:</p>

<p><code>diff
const #2 = String       #25;    //  hello,world
const #3 = String       #26;    //  hello,world.
...
public void test1()   throws java.lang.Exception;
  Code:
   Stack=1, Locals=4, Args_size=1
   0:   ldc     #2; //String hello,world
   2:   astore_1
   3:   ldc     #3; //String hello,world.
   5:   astore_2
   6:   ldc     #3; //String hello,world.
   8:   astore_3
   9:   return
</code></p>

<p>那么，如何让运行时产生的字符串放到常量池里边呢? 可以借助String类的intern方法。
例如下面的用法</p>

<p><code>java
String m = "hello,world";
String u = m.substring(0,2);
String v = u.intern();
</code></p>

<p>上面我们已经知道m,n使用的是同一个字符数组，但intern方法会到常量池里边去寻找字符串"he",如果找到的话，就直接返回该字符串，
否则就在常量池里边创建一个并返回，所以v使用的字符数组和m,n不是同一个。画成图的话就是这样的:</p>

<p><img src="/assets/images/2013/string/string6.png" alt="intern在内存中的布局" /></p>

<h2>字符串的内存释放问题</h2>

<p>像字面量字符串，因为存放在常量池里边，被常量池引用着，是没法被GC的。例如下面的代码:</p>

<p>``` java
String m = "hello,world";
String n = m.substring(0,2);</p>

<p>m = null;
n = null;
```</p>

<p>经过上述的操作，画成图的话就是这样的:</p>

<p><img src="/assets/images/2013/string/string7.png" alt="内存释放后的布局" /></p>

<p>而经过上面的分析，我们知道像substring、split等方法得到的结果都是引用原字符数组的。
如果某字符串很大，而且不是在常量池里存在的，当你采用substring等方法拿到一小部分新字符串之后，长期保存的话(例如用于缓存等)，
会造成原来的大字符数组意外无法被GC的问题。</p>

<p>关于这个问题，常见的解决办法就是使用new String(String original)或java.io.StreamTokenizer类。并且在网上已经有比较广泛的讨论，大家可以去阅读一下:</p>

<ul>
<li><a href="http://blog.xebia.com/2007/10/04/leaking-memory-in-java/">Leaking Memory in Java</a></li>
<li><a href="http://www.iteye.com/topic/626801">优化变成了忧患：String类的split方法引起的内存泄漏</a></li>
</ul>


<h2>结论</h2>

<ul>
<li>任何时候，比较字符串内容都应该使用equals方法</li>
<li>修改字符串操作，应该使用StringBuffer，StringBuilder</li>
<li>可以使用intern方法让运行时产生字符串的复用常量池中的字符串</li>
<li>字符串操作可能会复用原字符数组，在某些情况可能造成内存泄露的问题</li>
</ul>

]]></content>
  </entry>
  
</feed>
