<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2014-01-19T17:40:35+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[对UC文章《实时监控Android设备网络包》的补充]]></title>
    <link href="http://mccxj.github.com/blog/20131227_classloader-test.html"/>
    <updated>2013-12-27T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/classloader-test</id>
    <content type="html"><![CDATA[<p>类加载和程序运行是有些关系的，不妨来测试一下。<br/>
难度:中高级</p>

<h2>独立进程篇</h2>

<p>假设有下面的类文件：</p>

<p>```java
// Main.java
package com.github.mccxj.test;</p>

<p>public class Main {
  public static void main(String[] args){</p>

<pre><code>new TestServlet().test();
</code></pre>

<p>  }
}</p>

<p>// TestServlet.Java
package com.github.mccxj.test;</p>

<p>public class TestServlet {
  public void test() {</p>

<pre><code>InputStream is = TestServlet.class.getClassLoader().getResourceAsStream("config.properties");
if(is == null){
  throw new RuntimeException("couId not found config.properties");
}
</code></pre>

<p>  }
}
```
假设目录结构是这样的，其中jar下面的表示是在jar包里边的内容:</p>

<p>``` bash
test</p>

<pre><code>-lib
    -test.jar
      -com/github/mccxj/test/Main.class
-main.jar
    -com/github/mccxj/test/TestServlet.class
    -config.properties
</code></pre>

<p>```</p>

<p>请问：</p>

<ol>
<li>执行java -cp main.jar;lib/test.jar com.github.mccxj.test.Main会出错么？</li>
<li>执行java -cp main.jar -Djava.ext.dirs=./lib com.github.mccxj.test.Main结果是怎样？</li>
</ol>


<p>继续调整目录结果如下：</p>

<p>``` bash
test</p>

<pre><code>-lib
    -test.jar
        -com/github/mccxj/test/Main.class
    -main.jar
        -com/github/mccxj/test/TestServlet.class
        -config.properties
</code></pre>

<p>```</p>

<p>再请问</p>

<ol>
<li>执行java -Djava.ext.dirs=./lib com.github.mccxj.test.Main结果是怎样？</li>
</ol>


<p>继续调整一下TestServlet的代码：</p>

<p>```diff
// TestServlet.Java
package com.github.mccxj.test;</p>

<p>public class TestServlet {
  public void test() {
-    InputStream is = TestServlet.class.getClassLoader().getResourceAsStream("config.properties");
+    InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("config.properties");</p>

<pre><code>if(is == null){
  throw new RuntimeException("couId not found config.properties");
}
</code></pre>

<p>  }
}
```</p>

<p>把目录结构恢复成：</p>

<p>``` bash
test</p>

<pre><code>-lib
    -test.jar
      -com/github/mccxj/test/Main.class
-main.jar
    -com/github/mccxj/test/TestServlet.class
    -config.properties
</code></pre>

<p>```</p>

<p>请问:</p>

<ol>
<li>执行java -cp   main.jar;lib/test.jar com.github.mccxj.test.Main会出错么？</li>
<li>执行java   -cp main.jar -Djava.ext.dirs=./lib com.github.mccxj.test.Main结果又是怎样？</li>
</ol>


<p>最后调整目录结果如下：</p>

<p>``` bash
test</p>

<pre><code>-lib
    -test.jar
        -com/github/mccxj/test/Main.class
    -main.jar
        -com/github/mccxj/test/TestServlet.class
        -config.properties
</code></pre>

<p>```</p>

<ol>
<li>执行java -Djava.ext.dirs=./lib com.github.mccxj.test.Main结果是怎样？</li>
</ol>


<h2>Web应用服务器篇</h2>

<p>下面的例子，以tomcat为例。
假设有下面的Servlet文件，并打包成test.jar:</p>

<p>```java
// TestServlet.java
package com.github.mccxj.test;</p>

<p>public class TestServlet extends HttpServlet {</p>

<pre><code>private static Atomiclnteger al = new AtomicInteger();
private Atomiclnteger a2 = new AtomicInteger();

@Override
public void service(ServletRequest arg0, ServletResponse arg1) throws Servlet Exception, IOException {
    System.out.printIn(String.valueOf(al.incrementAndGet()));
    System.out.printIn(String.valueOf(a2.incrementAndGet()));
}
</code></pre>

<p>}
```</p>

<p>并部署两个应用程序appa、appb,在他们的WEB_INF/web.xml添加了下面的内容</p>

<p><code>xml
&lt;servlet&gt;
  &lt;servlet-name&gt;test&lt;/servlet-name&gt;
  &lt;display-name&gt;test servlet&lt;/display-name&gt;
  &lt;servlet-class&gt;com.huawei.test.TestServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;test&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/test&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></p>

<p>大家应该听说过Servlet是单例的概念，也可能听过Web应用服务器有共享类的机制。那么，请问：</p>

<ol>
<li>现在把test.jar扔到appa和appb的WEB_INF/lib目录中，启动tomcat，先访问/appa/test两次，再访问/appb/test, 此时会输出什么？</li>
<li>继续把test.jar都移除掉，只添加到TOMCAT_HOME/lib目录中，启动tomcat，先访问/appa/test两次，再访问/appb/test, 此时会输出什么？</li>
<li>最后把test.jar拷贝一份到appa的WEB_INF/lib目录中，启动tomcat，先访问/appa/test两次，再访问/appb/test, 此时会输出什么？</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对UC文章《实时监控Android设备网络包》的补充]]></title>
    <link href="http://mccxj.github.com/blog/20131227_android-tcpdump-netcat-addon.html"/>
    <updated>2013-12-27T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/android-tcpdump-netcat-addon</id>
    <content type="html"><![CDATA[<p>补充的内容，主要是一些细节的问题，备忘.</p>

<h2>编译netcat</h2>

<p>android上自己好像带了一个，不过也可以自己编译一个。 我这里使用cygwin来编译的，首先去下载源码。</p>

<p>```bash</p>

<h1>cygwin</h1>

<p>cd /cygdrive/d/
mkdir -p netcat/toolchain</p>

<p>export NDK=/cygdrive/d/android-ndk-r8e
/cygdrive/d/android-ndk-r8e/build/tools/make-standalone-toolchain.sh --platform=android-8 --install-dir=netcat/toolchain
export PATH='pwd'/netcat/toolchain/bin:$PATH
export CC=arm-linux-androideabi-gcc
export RANLIB=arm-linux-androideabi-ranlib
export AR=arm-linux-and roideabi-ar
export LD=arm-linux-androideabi-ld</p>

<h1>开始编译源码</h1>

<p>cd netcat-0.7.1/
./configure —host=arm-linux
make</p>

<h1>用file进行检测一下</h1>

<p>file src/netcat
src/netcat: ELF 32-bit LSB executable, ARM, version1 (SYSV), ...</p>

<h1>发到android上去</h1>

<p>adb push src/netcat /data/local/netcat
adb shell chmod 777 /data/local/netcat
```</p>

<h2>tcpdump的使用</h2>

<p>如果只是监听所有的包，可以用下面的：
<code>bash
adb shell "tcpdump -n -s 0 -w - | nc -I -p 11233"
</code></p>

<p>如果先监听端口的话，又想转发的话，写法有点特别。
<code>bash
adb shell "tcpdump -X -n -s 0 -w - port 5000 | nc -l -p 11233"
</code></p>

<p>另外，如果像我这样，有cygwin的话，就已经有nc命令了，可以像下面一样进行转发。
<code>bash
adb forward tcp:11333 tcp:11233 &amp;&amp; nc -v 127.0.0.1 | /cygdriver/d/Wireshark/Wireshark.exe -k -S -i -
</code></p>
]]></content>
  </entry>
  
</feed>
