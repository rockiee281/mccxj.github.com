<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sinatra | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/sinatra/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2014-03-05T22:23:25+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[sinatra分析(旧)]]></title>
    <link href="http://mccxj.github.com/blog/20121202_sinatra.html"/>
    <updated>2012-12-02T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/sinatra</id>
    <content type="html"><![CDATA[<p>这是10年初写的了:)</p>

<h2>sinatra简介</h2>

<ul>
<li>Sinatra is a DSL for quickly creating web applications in Ruby with minimal。</li>
<li>Fewer classes, less inheritance</li>
<li>controller object mapping &amp; routes vs. URLs---Dont's fear the URLs</li>
<li>Exposed Simplicity instead of hidden complexity</li>
<li>Small things, loosely joined, written fast</li>
</ul>


<h2>sinatra分析</h2>

<h3>Rack机制</h3>

<p>sinatra 作为一个web框架，是基于rack规范的。rack规范和Java的servlet规范有点类似，Rack中间件和filter机制有些类似，
都是能够拦截request/response做一些事情。所谓的rack兼容的中间件无非是一个可以执行 call(env) 的对象，详细关于rack的内容可以参考rack官网，还有这个rack入门文档也很好。
在源码中可以看到，sinatra的Request和Response都是基于rack扩展的，并对Rack::Request和Rack::Response分别做了一些调整。
sinatra是通过Application.run!来启动服务器的
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;     def run!(options={})</span>
<span class="sr">        set options</span>
<span class="sr">        handler      = detect_rack_handler</span>
<span class="sr">        handler_name = handler.name.gsub(/</span><span class="o">.</span><span class="n">*</span><span class="o">::</span><span class="sr">/, &#39;&#39;)</span>
<span class="sr">        puts &quot;== Sinatra/</span><span class="c1">#{Sinatra::VERSION} has taken the stage &quot; +</span>
          <span class="s2">&quot;on </span><span class="si">#{</span><span class="n">port</span><span class="si">}</span><span class="s2"> for </span><span class="si">#{</span><span class="n">environment</span><span class="si">}</span><span class="s2"> with backup from </span><span class="si">#{</span><span class="n">handler_name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">unless</span> <span class="n">handler_name</span> <span class="o">=~</span><span class="sr">/cgi/i</span>
        <span class="n">handler</span><span class="o">.</span><span class="n">run</span> <span class="nb">self</span><span class="p">,</span> <span class="ss">:Host</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">bind</span><span class="p">,</span> <span class="ss">:Port</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">port</span> <span class="k">do</span> <span class="o">|</span><span class="n">server</span><span class="o">|</span>
          <span class="nb">trap</span><span class="p">(</span><span class="ss">:INT</span><span class="p">)</span> <span class="k">do</span>
            <span class="c1">## Use thins&#39; hard #stop! if available, otherwise just #stop</span>
            <span class="n">server</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:stop!</span><span class="p">)</span> <span class="p">?</span> <span class="n">server</span><span class="o">.</span><span class="n">stop!</span> <span class="p">:</span> <span class="n">server</span><span class="o">.</span><span class="n">stop</span>
            <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">== Sinatra has ended his set (crowd applauds)&quot;</span> <span class="k">unless</span> <span class="n">handler_name</span> <span class="o">=~</span><span class="sr">/cgi/i</span>
          <span class="k">end</span>
          <span class="n">set</span> <span class="ss">:running</span><span class="p">,</span> <span class="kp">true</span>
        <span class="k">end</span>
      <span class="k">rescue</span> <span class="ss">Errno</span><span class="p">:</span><span class="ss">:EADDRINUSE</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">e</span>
        <span class="nb">puts</span> <span class="s2">&quot;== Someone is already performing on port </span><span class="si">#{</span><span class="n">port</span><span class="si">}</span><span class="s2">!&quot;</span>
      <span class="k">end</span>
<span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>
</code></pre></div></p>

<p>其中detect_rack_handler是通过 Rack::Handler.get来检测rack处理器的，默认的server有thin/mongrel/webrick,绑定的地址是 0.0.0.0，端口是4567
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;module Sinatra</span>
<span class="sr">    class Base</span>
<span class="sr">        set :server, %w[thin mongrel webrick]</span>
<span class="sr">        set :bind, &#39;0.0.0.0&#39;</span>
<span class="sr">        set :port, 4567</span>
<span class="sr">    end</span>
<span class="sr">end</span>
<span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>

<span class="sr">&lt;p&gt;</span>
</code></pre></div></p>

<p>注意到handler.run self, :Host =&gt; bind, :Port =&gt; port do |server|,这个self指的是Sinatra::Base，根据rack规范，最终的请求的入口就是 Sinatra::Base.call(env)方法
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;      def prototype</span>
<span class="sr">        @prototype ||= new</span>
<span class="sr">      end</span>

<span class="sr">      # Create a new instance of the class fronted by its middleware</span>
<span class="sr">      # pipeline. The object is guaranteed to respond to #call but may not be</span>
<span class="sr">      # an instance of the class new was called on.</span>
<span class="sr">      def new(*args, &amp;amp;bk)</span>
<span class="sr">        builder = Rack::Builder.new</span>
<span class="sr">        builder.use Rack::Session::Cookie if sessions?</span>
<span class="sr">        builder.use Rack::CommonLogger    if logging?</span>
<span class="sr">        builder.use Rack::MethodOverride  if method_override?</span>
<span class="sr">        builder.use ShowExceptions        if show_exceptions?</span>
<span class="sr">        middleware.each { |c,a,b| builder.use(c, *a, &amp;amp;b) }</span>

<span class="sr">        builder.run super</span>
<span class="sr">        builder.to_app</span>
<span class="sr">      end</span>

<span class="sr">      def call(env)</span>
<span class="sr">        synchronize { prototype.call(env) }</span>
<span class="sr">      end</span>
<span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>

<span class="sr">&lt;p&gt;</span>
</code></pre></div>
从call方法可以看到，是通过生成一个Sinatra::Base实例对象来运行的，最终会调用的是call(env) -> call!(env)，
接下去的工作就是等客户端发送请求过来就可以了。在生成这个实例对象@prototype的时候,直接引入rack中间件机制，
同样，sinatra允许你使用use方法来增加新的中间件(use只是把中间件加入@middleware变量中去而已)。这样sinatra就已经启动起来了。</p>

<h3>路由机制</h3>

<p>sinatra 的路由机制和rails不大一样，sinatra是在controller里边用get/post path这样来指定的。
而rails是把controller和map分开处理，通过map来找到对应的controller和action。
rails当初这么搞主要是为了兼容controller和路由不匹配的情况,个人觉得sinatra的写法是非常直观的，也非常的灵活。
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;delegate :get, :put, :post, :delete, :head, :template, :layout,</span>
<span class="sr">             :before, :after, :error, :not_found, :configure, :set, :mime_type,</span>
<span class="sr">             :enable, :disable, :use, :development?, :test?, :production?,</span>
<span class="sr">             :helpers, :settings</span>
<span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>

<span class="sr">&lt;p&gt;</span>
</code></pre></div></p>

<p>看 main.rb可以看到include Sinatra::Delegator，可以把get/post等众多方法代理给Sinatra::Application去执行，
在后面使用get '/' do xxx end的时候其实会调用Sinatra::Application(即Sinatra::Base)的get方法。
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;  require &#39;rubygems&#39;</span>
<span class="sr">  require &#39;sinatra&#39;</span>
<span class="sr">  get &#39;/</span><span class="s1">&#39; do</span>
<span class="s1">    &#39;</span><span class="no">Hello</span> <span class="n">world!</span><span class="err">&#39;</span>
  <span class="k">end</span>
<span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>
</code></pre></div></p>

<p>例如这样一个简单的web应用就可以响应'/'的请求路径，那么Sinatra::Base是怎么识别到这个路由的呢?我们继续来看看上面的get方法做了什么事情，
可以看到最终是调用route方法的(同时，从代码可以看到sinatra支持get/post/put/post/delete/head几种method的请求)。
按照我们的大概思路，在看到某个请求方法的时候，sinatra会把{请求类型<em>路径 => 代码块}放到一个专门放路由的地方上去，然后在每一次请求调用call(env)的时候，
根据“请求类型</em>路径”来获得需要执行的代码块。好，继续看看 route的代码是怎么实现的?
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;      def route(verb, path, options={}, &amp;amp;block)</span>
<span class="sr">        # Because of self.options.host</span>
<span class="sr">        host_name(options.delete(:bind)) if options.key?(:host)</span>
<span class="sr">        options.each {|option, args| send(option, *args)}</span>

<span class="sr">        pattern, keys = compile(path)</span>
<span class="sr">        conditions, @conditions = @conditions, []</span>

<span class="sr">       define_method &quot;</span><span class="si">#{</span><span class="n">verb</span><span class="si">}</span><span class="sr"> </span><span class="si">#{</span><span class="n">path</span><span class="si">}</span><span class="sr">&quot;, &amp;amp;block</span>
<span class="sr">        unbound_method = instance_method(&quot;</span><span class="si">#{</span><span class="n">verb</span><span class="si">}</span><span class="sr"> </span><span class="si">#{</span><span class="n">path</span><span class="si">}</span><span class="sr">&quot;)</span>
<span class="sr">        block =</span>
<span class="sr">          if block.arity != 0</span>
<span class="sr">            proc { unbound_method.bind(self).call(*@block_params) }</span>
<span class="sr">          else</span>
<span class="sr">            proc { unbound_method.bind(self).call }</span>
<span class="sr">          end</span>

<span class="sr">        invoke_hook(:route_added, verb, path, block)</span>

<span class="sr">        (@routes[verb] ||= []).</span>
<span class="sr">          push([pattern, keys, conditions, block]).last</span>
<span class="sr">      end</span>
<span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>

<span class="sr">&lt;p&gt;</span>
</code></pre></div>
这个代码处理的事情比较多，我们来仔细分析分析，前面两句代码是用来记录能够处理的请求的约束(例如特定的host_name,user_agent),
然后compile(path)的工作是把path换成一个正则表达式(这样通过match就可以获得匹配的组)，还有提取keys(例如*的就变成 splat，:name就变成name)。
重要的是把get '/' do xxx end动态生成一个"#{verb} #{path}"的方法并最终封装成一个带有上下文状态的proc对象，
最终是把[pattern, keys, conditions, block]加入@routes[verb]里边去。而call(env)能够处理请求就得靠这个@routes来实现。</p>

<p>先来看看call(env) -&gt; call!(env)，最重要的部分是invoke { dispatch! }，可以看到dispatch!的整个流程是
判断并处理static文件 -&gt; before_filter! -&gt; route! -&gt; after_filter!，主要的处理过程是route!方法
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;   def route!(base=self.class, pass_block=nil)</span>
<span class="sr">      if routes = base.routes[@request.request_method]</span>
<span class="sr">        original_params = @params</span>
<span class="sr">        path            = unescape(@request.path_info)</span>

<span class="sr">        routes.each do |pattern, keys, conditions, block|</span>
<span class="sr">          if match = pattern.match(path)</span>
<span class="sr">            values = match.captures.to_a</span>
<span class="sr">            params =</span>
<span class="sr">              if keys.any?</span>
<span class="sr">                keys.zip(values).inject({}) do |hash,(k,v)|</span>
<span class="sr">                  if k == &#39;splat&#39;</span>
<span class="sr">                    (hash[k] ||= []) &amp;lt; values}</span>
<span class="sr">              else</span>
<span class="sr">                {}</span>
<span class="sr">              end</span>
<span class="sr">            @params = original_params.merge(params)</span>
<span class="sr">            @block_params = values</span>

<span class="sr">            pass_block = catch(:pass) do</span>
<span class="sr">              conditions.each { |cond|</span>
<span class="sr">                throw :pass if instance_eval(&amp;amp;cond) == false }</span>
<span class="sr">              route_eval(&amp;amp;block)</span>
<span class="sr">            end</span>
<span class="sr">          end</span>
<span class="sr">        end</span>

<span class="sr">        @params = original_params</span>
<span class="sr">      end</span>
<span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>

<span class="sr">&lt;p&gt;</span>
</code></pre></div>
首先sinatra先从＠routes里边取得符合请求类型的[pattern, keys, conditions, block]列表，然后逐个扫描，
通过pattern来match路径，如果符合的话，取得通配符，命名参数的值并封装到params去(得益于 compile(path)的工作)。
接下去判断conditions是否符合，如果都符合，则执行业务，即block。整个流程处理完之后，把 params恢复为原本的状态。</p>

<h3>拦截器</h3>

<p>在上面已经提到，sinatra的拦截器是通过before_filter!和after_filter!来执行的，如下所示:
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;    def before_filter!(base=self.class)</span>
<span class="sr">      before_filter!(base.superclass) if base.superclass.respond_to?(:before_filters)</span>
<span class="sr">      base.before_filters.each { |block| instance_eval(&amp;amp;block) }</span>
<span class="sr">    end</span>
<span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>

<span class="sr">&lt;p&gt;</span>
</code></pre></div>
配置过滤器也非常简单，定义一个前置过滤器，例如
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;  before do</span>
<span class="sr">    @note = &#39;Hi!&#39;</span>
<span class="sr">    request.path_info = &#39;/</span><span class="n">foo</span><span class="o">/</span><span class="n">bar</span><span class="o">/</span><span class="n">baz</span><span class="err">&#39;</span>
  <span class="k">end</span>
<span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>
</code></pre></div>
sinatra通过Sinatra::Base的before把block加入到@before_filters中去，这个应该很容易明白的。
不过，这个拦截器功能比起rails那个显得简陋了，毕竟不能直接针对某些路径进行拦截处理。</p>

<h3>模板渲染</h3>

<p>sinatra通过Tilt实现多模板的渲染机制，生成页面的过程是在业务代码块那里注明的，例如
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;  require &#39;erb&#39;</span>
<span class="sr">  get &#39;/</span><span class="err">&#39;</span> <span class="k">do</span>
    <span class="n">erb</span> <span class="ss">:index</span>
  <span class="k">end</span>
<span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>
</code></pre></div>
sinatra的模板方法是在Sinatra::Templates模块里边定义的，能够支持erb,erubis,haml,sass,less,builder,具体的实现如下：
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;    def render(engine, data, options={}, locals={}, &amp;amp;block)</span>
<span class="sr">      # merge app-level options</span>
<span class="sr">      options = settings.send(engine).merge(options) if settings.respond_to?(engine)</span>

<span class="sr">      # extract generic options</span>
<span class="sr">      locals = options.delete(:locals) || locals || {}</span>
<span class="sr">      views = options.delete(:views) || settings.views || &quot;./</span><span class="n">views</span><span class="s2">&quot;</span>
<span class="s2">      layout = options.delete(:layout)</span>
<span class="s2">      layout = :layout if layout.nil? || layout == true</span>

<span class="s2">      # compile and render template</span>
<span class="s2">      template = compile_template(engine, data, options, views)</span>
<span class="s2">      output = template.render(self, locals, &amp;amp;block)</span>

<span class="s2">      # render layout</span>
<span class="s2">      if layout</span>
<span class="s2">        begin</span>
<span class="s2">          options = options.merge(:views =&amp;gt; views, :layout =&amp;gt; false)</span>
<span class="s2">          output = render(engine, layout, options, locals) { output }</span>
<span class="s2">        rescue Errno::ENOENT</span>
<span class="s2">        end</span>
<span class="s2">      end</span>

<span class="s2">      output</span>
<span class="s2">    end</span>
<span class="s2">&lt;/code&gt;&lt;/pre&gt;</span>

<span class="s2">&lt;p&gt;</span>
</code></pre></div>
具体的流程是先找到template engine，通过template的render方法渲染子页面，然后在把子页面的内容作为一个block参数放到渲染layout的render方法上去，
这样在父页面里边的yield就会被子页面的内容所取代，从而实现整体页面的渲染。</p>

<h3>错误及状态处理</h3>

<p>sinatra在这方面的处理，我觉得非常巧妙，还认识了一些从来没用过的api。几个重要的特性：
<div class="highlight"><pre><code class="ruby"><span class="ss">halt</span><span class="p">:</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;  halt 410</span>
<span class="sr">  halt &#39;this will be the body&#39;</span>
<span class="sr">  halt 401, &#39;go away!&#39;</span>
<span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>

<span class="sr">&lt;p&gt;error:&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="n">error</span> <span class="k">do</span>
    <span class="s1">&#39;Sorry there was a nasty error - &#39;</span> <span class="o">+</span> <span class="n">env</span><span class="o">[</span><span class="s1">&#39;sinatra.error&#39;</span><span class="o">].</span><span class="n">name</span>
  <span class="k">end</span>
  <span class="n">error</span> <span class="no">MyCustomError</span> <span class="k">do</span>
    <span class="s1">&#39;So what happened was...&#39;</span> <span class="o">+</span> <span class="n">request</span><span class="o">.</span><span class="n">env</span><span class="o">[</span><span class="s1">&#39;sinatra.error&#39;</span><span class="o">].</span><span class="n">message</span>
  <span class="k">end</span>
  <span class="n">error</span> <span class="mi">400</span><span class="o">.</span><span class="n">.</span><span class="mi">510</span> <span class="k">do</span>
    <span class="s1">&#39;Boom&#39;</span>
  <span class="k">end</span>
<span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>
</code></pre></div>
error的实现很简单，只是把error code和block记录到＠errors上去，而not_found其实就是404的error了。halt从代码实现上看，它是throw一个halt的异常。
这些处理方式在sinatra最终是怎么处理的呢？我们先回到dispatch!这个主方法，从源码中可以看到如果是静态页面，会抛出halt(line 173),到了route!方法的时候，如下
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;pre&gt;&lt;code&gt;            pass_block = catch(:pass) do</span>
<span class="sr">              conditions.each { |cond|</span>
<span class="sr">                throw :pass if instance_eval(&amp;amp;cond) == false }</span>
<span class="sr">                route_eval(&amp;amp;block)</span>
<span class="sr">            end</span>
<span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>

<span class="sr">&lt;p&gt;</span>
</code></pre></div>
catch(args,&amp;block) 这个方法是会忽视在遇到pass异常的时候忽略异常并跳出block的运行，所以conditions验证不通过的时候，
就会转入下一个pattern验证，而在验证通过后到了route_eval(&amp;block) 就会抛出halt从而跳出循环，表示已经匹配成功。
抛出异常之后会在dispatch!通过rescue来处理。error_block!(*keys) 就是用来处理error的，＠errors根据error code来获取block，这样就可以输出自定义的错误页面了。</p>
]]></content>
  </entry>
  
</feed>
