<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 泄露 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/xie-lu/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2014-01-19T16:40:57+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[连接池泄露定位案例]]></title>
    <link href="http://mccxj.github.com/blog/20131126_connection-leak.html"/>
    <updated>2013-11-26T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/connection-leak</id>
    <content type="html"><![CDATA[<p>前阵子，其他项目组里边有个某项目频繁出现获取不到连接的问题，基本上每一天都出现一次。</p>

<p>打出来的javacore里面，有大量的线程等待获取连接。并且现场反映，从数据库那边监控到大量的空闲连接没有释放。</p>

<p>事实上，这个系统会用到两个数据源，其中有个是正常的。有意思的是，这几个月都没有新版本上载。</p>

<p>走读了java里边的连接获取释放逻辑，虽然获取和关闭的调用到处都是(没封装好)，但最后还是调用一些静态方法来完成的，并且都在finally块中进行了处理，感觉不会存在泄露的问题。</p>

<p>尝试看看能不能重现，运气还不错，在开发环境模拟生产的业务场景(业务功能不多，但逻辑处理流程比较长)进行了压力测试，也的确出现了这种情况。</p>

<p>既然能够重现问题，定位就方便许多了。我知道有Btrace这类神器可以帮助定位，但我没有使用过(下次再尝试一下)。我是通过修改代码来定位的，基本原理就是在获取连接时记录堆栈信息，在关闭时清除，这样出问题的时候就可以找到哪些地方有问题。其实用工具也是类似的做法。</p>

<p>大体上是这样的:</p>

<p>```java
// 用来存储堆栈信息
private static final Map&lt;Connection, Exception> conns = new ConcurrentHashMap&lt;Connection, Exception>();</p>

<p>// 当获取链接的时候
public Connection getConnection(){</p>

<pre><code>Connection conn = dataSource.getConnection();
conns.put(conn, new Exception());
return conn;
</code></pre>

<p>}</p>

<p>// 当释放链接的时候
public void releaseConnection(Connection conn){</p>

<pre><code>conns.remove(conn);
dataSource.close(conn);
</code></pre>

<p>}
```</p>

<p>修改后重新压力测试后，打开记录的堆栈一看，居然是在jsp里边获取的，真是顿时无语。</p>

<p>后来，虽然听说这个问题是其他原因引起的，导致非正常情况下走到这段逻辑，但这个地雷还是以前埋进去的，也怨不了别人。</p>

<p>其实，关于资源释放的逻辑封装，可以参考spring的jdbc封装(回调的方式)，又或许用ThreadLocal、拦截器等方式在整个应用上进行处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小心jsch的sftp连接泄露]]></title>
    <link href="http://mccxj.github.com/blog/20131106_jsch-session-connect.html"/>
    <updated>2013-11-06T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/jsch-session-connect</id>
    <content type="html"><![CDATA[<p>今天早上和一个同事处理一个现网问题，从javacore里边可以看到大量的Connect Thread，如下所示：
<code>java
Connect thread 192.168.1.100 session" prio=6 tid=0x042d3400 nid=0x1458 runnable [0x04e4f000]
</code></p>

<p>堆栈信息如下:
<code>java
...
com.jcraft.jsch.Session.run(Session.java:1193)
java.lang.Thread.run(Thread.java:619)
</code></p>

<p>怀疑是资源泄露了，jsch是一个sftp的工具库。检查jsch的使用代码，可以看到代码是有进行关闭的，如下所示：
```java</p>

<pre><code>JSch jsch = new JSch();
Session session = jsch.getSession("caixiaojian", "192.168.1.100", 22);
session.setPassword("******");
session.setConfig("StrictHostKeyChecking", "no");
session.connect();
Channel channel = session.openChannel("sftp");
channel.connect();
ChannelSftp c = (ChannelSftp) channel;

channel.connect();
//...
channel.disconnect();
</code></pre>

<p>```</p>

<p>不过从官方的<a href="http://www.jcraft.com/jsch/examples/Sftp.java.html">例子</a>上看到，最需要关闭的是session对象而不是channel对象。
于是写了一个简单的测试Demo，把上面的代码跑5次，看看能不能重现:</p>

<p>```bash</p>

<h1>jstack -l 3621 | grep Connect</h1>

<p>Connect thread 192.168.1.100 session" prio=6 tid=0x042d3400 nid=0x1458 runnable [0x04e4f000]
Connect thread 192.168.1.100 session" prio=6 tid=0x042d0400 nid=0x16c8 runnable [0x04def000]
Connect thread 192.168.1.100 session" prio=6 tid=0x041b4000 nid=0xd38 runnable [0x04d8f000]
Connect thread 192.168.1.100 session" prio=6 tid=0x041b2000 nid=0x166c runnable [0x04bcf000]
Connect thread 192.168.1.100 session" prio=6 tid=0x041b1000 nid=0x450 runnable [0x04b2f000]
```</p>

<p>果然出现了，试着在最后调用一下session.disconnect(),重试一下果然不存在了上述线程了。</p>
]]></content>
  </entry>
  
</feed>
