
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>小毛的胡思乱想</title>
  <meta name="author" content="蔡晓建">

  
  <meta name="description" content="Java参数传递只是传值 一开始学java，就有人告诉你，Java参数传递，只有传值，没有传引用。但是我在平时仍然发现，在面试时有不少人搞混，
也见过有人写出问题代码，特别是许多习惯c++编程习惯的童鞋。为了让大家都能理解，我们还是再来复习一遍。 什么是传引用 首先我们来看看什么是传引用方式? &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://mccxj.github.com/blog/page/4/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="小毛的胡思乱想" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">小毛的胡思乱想</a></h1>
  
    <h2>凡走过,必留痕迹.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:mccxj.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20130809_java-hell-parameter.html">怎么理解java参数传递只是传值方式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-09T00:00:00+08:00" pubdate data-updated="true">Aug 9<span>th</span>, 2013</time>
        
         | <a href="/blog/20130809_java-hell-parameter.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Java参数传递只是传值</h3>

<p>一开始学java，就有人告诉你，Java参数传递，只有传值，没有传引用。但是我在平时仍然发现，在面试时有不少人搞混，
也见过有人写出问题代码，特别是许多习惯c++编程习惯的童鞋。为了让大家都能理解，我们还是再来复习一遍。</p>

<h3>什么是传引用</h3>

<p>首先我们来看看什么是传引用方式? 这个概念在C++里边很常用，例如下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">Callback</span><span class="o">&amp;</span> <span class="n">cb</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用引用(第三个参数)，就相当于直接使用实参一样，可以直接改变对象的内容，甚至可以让它指向另外一个对象。
相对于传值(第二个参数)来说，可以减少拷贝对象带来消耗，相对于传递指针方式(第一个参数)，无需担心空指针问题，还能够改变对象的引用。</p>

<p>看上去，传递引用好像是集大成的功能，但实际使用上并不是每个参数都会这么搞。为什么? 因为它赋予子函数的权利太大，
对参数的任何修改都会受影响，特别是改变引用这种极端操作。</p>

<p>于是，Java大大减少了语法的灵活性，只保留了传值方式(因为没有指针，所以也没有所谓的指针传递)。</p>

<h3>从内存布局看传值</h3>

<p>因为没有指针，而且有基本类型和类类型的区别，所以有些童鞋对传值的理解有偏差。下面在从内存布局上看看。
在Java中，new出来的对象都是在heap里边生成，但是本地变量是在方法栈里边的。考虑下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="n">call</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">A</span> <span class="nf">call</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">){</span>
</span><span class='line'>   <span class="n">a</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">);</span>
</span><span class='line'>   <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>
</span><span class='line'>   <span class="n">a</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">);</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看图，从左到右，从上到下，其中左边的是本地变量列表，右边的是堆空间，每行一个小图，其他不解释。
<img src="https://f.cloud.github.com/assets/98360/941947/5b2d54c2-0161-11e3-98f7-52a4ed50d824.png" alt="test" /></p>

<h3>传的是什么值?</h3>

<p>上面列举的情况是类类型的情况，实际上传值做的是本地变量的拷贝，而不是堆对象的拷贝。有些人会产生疑惑，
主要是因为java在语法上隐藏了指针，其实，对于类类型的参数传递，和c++中传指针方式是一个道理的，只有基本类型才是实实在在的传值方式。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20130809_java-hell-date.html">Java中的日期工具</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-09T00:00:00+08:00" pubdate data-updated="true">Aug 9<span>th</span>, 2013</time>
        
         | <a href="/blog/20130809_java-hell-date.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>蹩脚的日期API</h3>

<p>众所周知，jdk自带的日期API用起来非常蹩脚，属于JDK中设计较差的典型。</p>

<p>首先我们来看看常见类的分工：</p>

<ul>
<li>Calendar实现的是日期和时间之间的转换,其他就没什么用了</li>
<li>DateFormat用来格式化和解析日期字符串</li>
<li>Date用来表示日期和时间信息</li>
</ul>


<p>下面我们再看看其中很混淆的一些设计:</p>

<ul>
<li>有两个Date类，分别是java.sql.Date和java.util.Date，前一个继承后一个，不要搞混了，通常我们是使用后一个。*</li>
<li>java.sql是用于数据库类型的，这个Date是一个单纯的日期类型，意思是没有时间的概念，如果要时间，应该选择java.sql.Timestamp。这是个很悲催的设计，把原来的Date功能阉割了。</li>
<li>注意Date的构造方法参数是很神奇的，年份是减去1900的数，月份是从0到11来表示的。</li>
<li>Date的getTime返回的时间是相对于“1970-01-01 00:00:00”的毫秒数差值</li>
<li>日期的调整、差距计算非常麻烦</li>
<li>这些类都不是线程安全的，特别是格式化功能，经常有人掉坑，是重灾区来的</li>
</ul>


<h3>API的替代品</h3>

<p>日期API实在是太烂了，幸好有其他开源选择，例如著名的Joda-Time，有兴趣的可以去试试。</p>

<p>另外，还有最新的关于日期API的规范:JSR-310。官方的描述叫做“This JSR will provide a new and improved date and time API for Java.”，JSR-310将解决许多现有Java日期API的设计问题。比如Date和Calendar目前是可变对象，你可以随意改变对象的日期或者时间，而Joda就将DateTime对象设计成String对象一样地不可变，能够带来线程安全等等的好处，因此这一点也将被JSR-310采纳。</p>

<h3>时间的度量</h3>

<p>有两个特殊的API是和计时有关的，就是System.currentTimeMillis和System.nanoTime。两个的区别和用法如下:</p>

<p>currentTimeMillis的值是相对于“1970-01-01 00:00:00”的毫秒数差值，跟new Date().getTime是一样的，因为new Date()就调用currentTimeMillis作为参数。大家应该对这个是比较熟悉的。</p>

<p>nanaTime是jdk5才增加的API，能够提供更为精确的时间度量(纳秒呀，精度太高了，应该是系统时钟的近似值)。不过，它返回的是一个相对时间，而不像currentTimeMillis是一直增长的。所以要让时间有意义，必须用上时间差，就是用两个nanaTime来相减。</p>

<p>简单来说，currentTimeMillis表示的是精确时间点的概念，nanaTime表示的是相对时间差的概念。用来表示一段时间差的话，nanoTime可以提供更好的精度。</p>

<p>顺便提一下，JDK没有度量微妙的API，需要的话只能自己模拟了。</p>

<h3>更多时间工具</h3>

<p>如果是多线程编程的话，就不能不忽视java.util.concurrent工具包。它也提供了一些时间方面的工具，如TimeUnit类，简单来说，它是一个单位转换的辅助类，可以用更加直观的时间单位来操作。例如休眠3s,可以用下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3</span><span class="n">d</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个类也用于这个包里边许多带超时机制的API中，例如使用lock的API是这样使用的的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="o">...;</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">tryLock</span><span class="o">(</span><span class="mi">50L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// manipulate protected state</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// perform alternative actions</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于这个并发工具包的内容，以后有机会再介绍。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20130807_dom-operation-is-not-sync.html">Dom操作和渲染并不是同步的</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-07T00:00:00+08:00" pubdate data-updated="true">Aug 7<span>th</span>, 2013</time>
        
         | <a href="/blog/20130807_dom-operation-is-not-sync.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一个在ie6不兼容的线上问题</h3>

<p>昨天，有同事找我看一个线上问题，说一个在ie8测试通过的功能，在ie6上不能正常使用。
一开始，他用alert定位到是哪部分代码出问题，并认为后面有部分代码没有执行。奇怪的是，在这中间加上alert语句的话，
在ie6上也是能够正常运行的。</p>

<p>这部分代码简化后大概是这样的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;select</span> <span class="na">onclick=</span><span class="s">&quot;javascript:selectbank(this);&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">&quot;&quot;</span><span class="nt">&gt;</span>--all--<span class="nt">&lt;/option&gt;</span>
</span><span class='line'><span class="nt">&lt;/select&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">// get val and desc from a pop up page</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">opt</span> <span class="o">=</span> <span class="s2">&quot;&lt;option value=&#39;&quot;</span> <span class="o">+</span> <span class="nx">val</span> <span class="o">+</span> <span class="s2">&quot;&#39;&gt;&quot;</span> <span class="o">+</span> <span class="nx">desc</span> <span class="o">+</span> <span class="s2">&quot;&lt;/option&gt;&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">opt</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">val</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// alert(&quot;test&quot;);</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我发现没有加alert的时候，页面会报js错误。并且，这种情况在ie8不会出现。</p>

<h3>Dom操作和渲染并不是同步的</h3>

<p>为什么会出现这种情况，这主要因为Dom操作比普通js操作的消耗大很多，因为它需要改变页面元素，
导致页面出现重新渲染的情况，这取决于浏览器的实现。像ie8等比较高级的浏览器，渲染、js速度都要快许多，
所以不会出现这种情况。而ie6太慢了，很可能还没反应过来。</p>

<p>类似的情况是，在一个js调用过程中(某次事件)，如果你频繁修改dom，浏览器很可能不会逐个生效，
而是几个操作一起生效，跟期望的有点不一样。在一些低端浏览器，可以做的优化是，让调用过程尽量快，
减少Dom操作，或者中间使用setTimeout休息一下。</p>

<p>而像上面的问题，修改成下面的代码就可以了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">// get val and desc from a pop up page</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">opt</span> <span class="o">=</span> <span class="s2">&quot;&lt;option selected value=&#39;&quot;</span> <span class="o">+</span> <span class="nx">val</span> <span class="o">+</span> <span class="s2">&quot;&#39;&gt;&quot;</span> <span class="o">+</span> <span class="nx">desc</span> <span class="o">+</span> <span class="s2">&quot;&lt;/option&gt;&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">opt</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// alert(&quot;test&quot;);</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20130806_was-connection-close-fail.html">WebSphere数据源中的连接被意外关闭案例</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-06T00:00:00+08:00" pubdate data-updated="true">Aug 6<span>th</span>, 2013</time>
        
         | <a href="/blog/20130806_was-connection-close-fail.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>频繁创建连接的现象</h3>

<p>前阵子维护反馈说，oracle数据库每秒创建连接数过高，而主要来源来自于WebSphere集群所在的主机。
按理说，使用连接池的应用，连接是不会很频繁的。追溯一下所在主机的程序，发现可疑对象是一个使用jdbc轮子的应用。
就是自己写了一套代码封装了jdbc操作，虽然连接是从数据源中获取的。</p>

<p>但是，单纯看代码，的确没发现有什么问题，该关闭的地方也关闭，不存在泄露的情况。再说，这种现象也不是泄露的表现。
另外，由于生产上的数据库连接串，开发人员是没有的，所以生成都是通过jndi的方式来处理的，不存在盗链的代码。</p>

<p>不过，我们还是在日志里边发现一些问题。在SystemOut的日志里边，频繁出现类似下面的异常信息:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">[</span><span class="mi">12</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="mi">27</span> <span class="mi">9</span><span class="o">:</span><span class="mi">01</span><span class="o">:</span><span class="mi">29</span><span class="o">:</span><span class="mi">262</span> <span class="n">GMT</span><span class="o">+</span><span class="mi">08</span><span class="o">:</span><span class="mi">00</span><span class="o">]</span> <span class="mi">00000038</span> <span class="n">MCWrapper</span>     <span class="n">E</span>   <span class="nl">J2CA0081E:</span>
</span><span class='line'><span class="err">尝试对资源</span> <span class="n">ecareDB</span> <span class="err">的</span> <span class="n">ManagedConnection</span> <span class="n">WSRdbManagedConnectionImpl</span><span class="err">@</span><span class="mi">23</span><span class="n">f823f8</span> <span class="err">执行方法</span> <span class="n">cleanup</span> <span class="err">时，</span>
</span><span class='line'><span class="err">方法</span> <span class="n">cleanup</span> <span class="err">失败。捕获的异常：</span><span class="n">com</span><span class="o">.</span><span class="na">ibm</span><span class="o">.</span><span class="na">ws</span><span class="o">.</span><span class="na">exception</span><span class="o">.</span><span class="na">WsException</span><span class="o">:</span> <span class="nl">DSRA0080E:</span>
</span><span class='line'><span class="n">An</span> <span class="n">exception</span> <span class="n">was</span> <span class="n">received</span> <span class="n">by</span> <span class="n">the</span> <span class="n">Data</span> <span class="n">Store</span> <span class="n">Adapter</span><span class="o">.</span> <span class="n">See</span> <span class="n">original</span> <span class="n">exception</span> <span class="nl">message:</span>
</span><span class='line'> <span class="n">Cannot</span> <span class="n">call</span> <span class="err">&#39;</span><span class="n">cleanup</span><span class="err">&#39;</span> <span class="n">on</span> <span class="n">a</span> <span class="n">ManagedConnection</span> <span class="k">while</span> <span class="n">it</span> <span class="n">is</span> <span class="n">still</span> <span class="n">in</span> <span class="n">a</span> <span class="n">transaction</span><span class="o">..</span>
</span></code></pre></td></tr></table></div></figure>


<p>异常的来源，居然是连接的close方法。</p>

<h3>为什么close会失败</h3>

<p>在WebSphere的资料上没有找到相关的描述，但是我在ibatis的文档上找到了相关的描述(ibatis developer guide的12-13页)：</p>

<p>The <transactionManager> element also allows an optional attribute commitRequired that can be true or
false.  Normally iBATIS will not commit transactions unless an insert, update, or delete operation has been
performed.  This is true even if you explicitly call the commitTransaction() method.  This behavior
creates problems in some cases.  If you want iBATIS to always commit transactions, even if no insert,
update, or delete operation has been performed, then set the value of the commitRequired attribute to true.
Examples of where this attribute is useful include:</p>

<ol>
<li><p>If you call a stored procedures that updates data as well as returning rows.  In that case you would
call the procedure with the queryForList() operation – so iBATIS would not normally commit the
transaction.  But then the updates would be rolled back.</p></li>
<li><p>In a WebSphere environment when you are using connection pooling and you use the JNDI
<dataSource> and the JDBC or JTA transaction manager.  WebSphere requires all transactions on
pooled connections to be committed or the connection will not be returned to the pool.</p></li>
</ol>


<p>Note that the commitRequired attribute has no effect when using the EXTERNAL transaction manager.</p>

<h3>结论及对策</h3>

<p>从上面的描述上看到，WebSphere环境的连接是需要提交事务的，否则会被意外关闭。
并且，如果选择ibatis的事务管理机制，就应该设置commitRequired属性，要么就应该使用spring的事务解决方案。</p>

<p>我们尝试给查询语句增加commit操作，果然异常信息不再出现，并且数据库连接数也大幅度减少了。
看来，在生产系统中还是应该优先考虑成熟的解决方案，不要随便造轮子。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20130630_object-balance-pool.html">带平衡的对象池设计</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-30T00:00:00+08:00" pubdate data-updated="true">Jun 30<span>th</span>, 2013</time>
        
         | <a href="/blog/20130630_object-balance-pool.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近有个需求，是关于一个Socket连接池的功能改造，要求实现下面的需求:</p>

<ol>
<li>可配置多个服务器地址</li>
<li>服务器地址可以配置权重(比如3:2:1)</li>
<li>连接池可以设置最小连接和最大连接</li>
<li>某服务器从崩溃中恢复后，连接池中的连接数可以自动恢复到服务器之间的权重比。</li>
<li>连接可设置最大空闲释放时间</li>
</ol>


<p>一开始有同事自定义了一个链表来做取数和归还的操作，在线程安全方面操作感觉还是有点麻烦。
后来我采用PriorityBlockingQueue来实现，其实就是内部变成了堆的结构。见下面的图:</p>

<p><img src="/assets/images/2013/pool/1.png" alt="数据结构" /></p>

<p><img src="/assets/images/2013/pool/2.png" alt="类图" /></p>

<p><img src="/assets/images/2013/pool/3.png" alt="状态图" /></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/5/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/3/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/20131126_connection-leak.html">连接池泄露定位案例</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131120_notebook-system-install.html">周日笔记本系统安装记事</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131108_mission-estimate.html">谈任务分解与评估</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131106_jsch-session-connect.html">小心jsch的sftp连接泄露</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131103_word-contact.html">单词接龙问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131029_youdao-note.html">有道云笔记使用感受</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131025_how-to-excel.html">excel读书心得</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130930_des.html">DES加解密总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130921_books.html">那些年，我读过的技术书</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130908_redis-introduction.html">redis简报</a>
      </li>
    
  </ul>
</section>

<section>
<iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=8&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=1735848865&verifier=fa40be14&dpc=1"></iframe>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/mccxj">@mccxj</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'mccxj',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - 蔡晓建 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'mccxj';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
