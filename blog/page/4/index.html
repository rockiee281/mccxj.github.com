
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>小毛的胡思乱想</title>
  <meta name="author" content="蔡晓建">

  
  <meta name="description" content="蹩脚的日期API 众所周知，jdk自带的日期API用起来非常蹩脚，属于JDK中设计较差的典型。 首先我们来看看常见类的分工： Calendar实现的是日期和时间之间的转换,其他就没什么用了
DateFormat用来格式化和解析日期字符串
Date用来表示日期和时间信息 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://mccxj.github.com/blog/page/4/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="小毛的胡思乱想" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">小毛的胡思乱想</a></h1>
  
    <h2>凡走过,必留痕迹.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:mccxj.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20130809_java-hell-date.html">Java中的日期工具</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-09T00:00:00+08:00" pubdate data-updated="true">Aug 9<span>th</span>, 2013</time>
        
         | <a href="/blog/20130809_java-hell-date.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>蹩脚的日期API</h3>

<p>众所周知，jdk自带的日期API用起来非常蹩脚，属于JDK中设计较差的典型。</p>

<p>首先我们来看看常见类的分工：</p>

<ul>
<li>Calendar实现的是日期和时间之间的转换,其他就没什么用了</li>
<li>DateFormat用来格式化和解析日期字符串</li>
<li>Date用来表示日期和时间信息</li>
</ul>


<p>下面我们再看看其中很混淆的一些设计:</p>

<ul>
<li>有两个Date类，分别是java.sql.Date和java.util.Date，前一个继承后一个，不要搞混了，通常我们是使用后一个。*</li>
<li>java.sql是用于数据库类型的，这个Date是一个单纯的日期类型，意思是没有时间的概念，如果要时间，应该选择java.sql.Timestamp。这是个很悲催的设计，把原来的Date功能阉割了。</li>
<li>注意Date的构造方法参数是很神奇的，年份是减去1900的数，月份是从0到11来表示的。</li>
<li>Date的getTime返回的时间是相对于“1970-01-01 00:00:00”的毫秒数差值</li>
<li>日期的调整、差距计算非常麻烦</li>
<li>这些类都不是线程安全的，特别是格式化功能，经常有人掉坑，是重灾区来的</li>
</ul>


<h3>API的替代品</h3>

<p>日期API实在是太烂了，幸好有其他开源选择，例如著名的Joda-Time，有兴趣的可以去试试。</p>

<p>另外，还有最新的关于日期API的规范:JSR-310。官方的描述叫做“This JSR will provide a new and improved date and time API for Java.”，JSR-310将解决许多现有Java日期API的设计问题。比如Date和Calendar目前是可变对象，你可以随意改变对象的日期或者时间，而Joda就将DateTime对象设计成String对象一样地不可变，能够带来线程安全等等的好处，因此这一点也将被JSR-310采纳。</p>

<h3>时间的度量</h3>

<p>有两个特殊的API是和计时有关的，就是System.currentTimeMillis和System.nanoTime。两个的区别和用法如下:</p>

<p>currentTimeMillis的值是相对于“1970-01-01 00:00:00”的毫秒数差值，跟new Date().getTime是一样的，因为new Date()就调用currentTimeMillis作为参数。大家应该对这个是比较熟悉的。</p>

<p>nanaTime是jdk5才增加的API，能够提供更为精确的时间度量(纳秒呀，精度太高了，应该是系统时钟的近似值)。不过，它返回的是一个相对时间，而不像currentTimeMillis是一直增长的。所以要让时间有意义，必须用上时间差，就是用两个nanaTime来相减。</p>

<p>简单来说，currentTimeMillis表示的是精确时间点的概念，nanaTime表示的是相对时间差的概念。用来表示一段时间差的话，nanoTime可以提供更好的精度。</p>

<p>顺便提一下，JDK没有度量微妙的API，需要的话只能自己模拟了。</p>

<h3>更多时间工具</h3>

<p>如果是多线程编程的话，就不能不忽视java.util.concurrent工具包。它也提供了一些时间方面的工具，如TimeUnit类，简单来说，它是一个单位转换的辅助类，可以用更加直观的时间单位来操作。例如休眠3s,可以用下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3</span><span class="n">d</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个类也用于这个包里边许多带超时机制的API中，例如使用lock的API是这样使用的的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="o">...;</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">tryLock</span><span class="o">(</span><span class="mi">50L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// manipulate protected state</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// perform alternative actions</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于这个并发工具包的内容，以后有机会再介绍。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20130807_dom-operation-is-not-sync.html">Dom操作和渲染并不是同步的</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-07T00:00:00+08:00" pubdate data-updated="true">Aug 7<span>th</span>, 2013</time>
        
         | <a href="/blog/20130807_dom-operation-is-not-sync.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一个在ie6不兼容的线上问题</h3>

<p>昨天，有同事找我看一个线上问题，说一个在ie8测试通过的功能，在ie6上不能正常使用。
一开始，他用alert定位到是哪部分代码出问题，并认为后面有部分代码没有执行。奇怪的是，在这中间加上alert语句的话，
在ie6上也是能够正常运行的。</p>

<p>这部分代码简化后大概是这样的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;select</span> <span class="na">onclick=</span><span class="s">&quot;javascript:selectbank(this);&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">&quot;&quot;</span><span class="nt">&gt;</span>--all--<span class="nt">&lt;/option&gt;</span>
</span><span class='line'><span class="nt">&lt;/select&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">// get val and desc from a pop up page</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">opt</span> <span class="o">=</span> <span class="s2">&quot;&lt;option value=&#39;&quot;</span> <span class="o">+</span> <span class="nx">val</span> <span class="o">+</span> <span class="s2">&quot;&#39;&gt;&quot;</span> <span class="o">+</span> <span class="nx">desc</span> <span class="o">+</span> <span class="s2">&quot;&lt;/option&gt;&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">opt</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">val</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// alert(&quot;test&quot;);</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我发现没有加alert的时候，页面会报js错误。并且，这种情况在ie8不会出现。</p>

<h3>Dom操作和渲染并不是同步的</h3>

<p>为什么会出现这种情况，这主要因为Dom操作比普通js操作的消耗大很多，因为它需要改变页面元素，
导致页面出现重新渲染的情况，这取决于浏览器的实现。像ie8等比较高级的浏览器，渲染、js速度都要快许多，
所以不会出现这种情况。而ie6太慢了，很可能还没反应过来。</p>

<p>类似的情况是，在一个js调用过程中(某次事件)，如果你频繁修改dom，浏览器很可能不会逐个生效，
而是几个操作一起生效，跟期望的有点不一样。在一些低端浏览器，可以做的优化是，让调用过程尽量快，
减少Dom操作，或者中间使用setTimeout休息一下。</p>

<p>而像上面的问题，修改成下面的代码就可以了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">// get val and desc from a pop up page</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">opt</span> <span class="o">=</span> <span class="s2">&quot;&lt;option selected value=&#39;&quot;</span> <span class="o">+</span> <span class="nx">val</span> <span class="o">+</span> <span class="s2">&quot;&#39;&gt;&quot;</span> <span class="o">+</span> <span class="nx">desc</span> <span class="o">+</span> <span class="s2">&quot;&lt;/option&gt;&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">opt</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// alert(&quot;test&quot;);</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20130806_was-connection-close-fail.html">WebSphere数据源中的连接被意外关闭案例</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-06T00:00:00+08:00" pubdate data-updated="true">Aug 6<span>th</span>, 2013</time>
        
         | <a href="/blog/20130806_was-connection-close-fail.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>频繁创建连接的现象</h3>

<p>前阵子维护反馈说，oracle数据库每秒创建连接数过高，而主要来源来自于WebSphere集群所在的主机。
按理说，使用连接池的应用，连接是不会很频繁的。追溯一下所在主机的程序，发现可疑对象是一个使用jdbc轮子的应用。
就是自己写了一套代码封装了jdbc操作，虽然连接是从数据源中获取的。</p>

<p>但是，单纯看代码，的确没发现有什么问题，该关闭的地方也关闭，不存在泄露的情况。再说，这种现象也不是泄露的表现。
另外，由于生产上的数据库连接串，开发人员是没有的，所以生成都是通过jndi的方式来处理的，不存在盗链的代码。</p>

<p>不过，我们还是在日志里边发现一些问题。在SystemOut的日志里边，频繁出现类似下面的异常信息:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">[</span><span class="mi">12</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="mi">27</span> <span class="mi">9</span><span class="o">:</span><span class="mi">01</span><span class="o">:</span><span class="mi">29</span><span class="o">:</span><span class="mi">262</span> <span class="n">GMT</span><span class="o">+</span><span class="mi">08</span><span class="o">:</span><span class="mi">00</span><span class="o">]</span> <span class="mi">00000038</span> <span class="n">MCWrapper</span>     <span class="n">E</span>   <span class="nl">J2CA0081E:</span>
</span><span class='line'><span class="err">尝试对资源</span> <span class="n">ecareDB</span> <span class="err">的</span> <span class="n">ManagedConnection</span> <span class="n">WSRdbManagedConnectionImpl</span><span class="err">@</span><span class="mi">23</span><span class="n">f823f8</span> <span class="err">执行方法</span> <span class="n">cleanup</span> <span class="err">时，</span>
</span><span class='line'><span class="err">方法</span> <span class="n">cleanup</span> <span class="err">失败。捕获的异常：</span><span class="n">com</span><span class="o">.</span><span class="na">ibm</span><span class="o">.</span><span class="na">ws</span><span class="o">.</span><span class="na">exception</span><span class="o">.</span><span class="na">WsException</span><span class="o">:</span> <span class="nl">DSRA0080E:</span>
</span><span class='line'><span class="n">An</span> <span class="n">exception</span> <span class="n">was</span> <span class="n">received</span> <span class="n">by</span> <span class="n">the</span> <span class="n">Data</span> <span class="n">Store</span> <span class="n">Adapter</span><span class="o">.</span> <span class="n">See</span> <span class="n">original</span> <span class="n">exception</span> <span class="nl">message:</span>
</span><span class='line'> <span class="n">Cannot</span> <span class="n">call</span> <span class="err">&#39;</span><span class="n">cleanup</span><span class="err">&#39;</span> <span class="n">on</span> <span class="n">a</span> <span class="n">ManagedConnection</span> <span class="k">while</span> <span class="n">it</span> <span class="n">is</span> <span class="n">still</span> <span class="n">in</span> <span class="n">a</span> <span class="n">transaction</span><span class="o">..</span>
</span></code></pre></td></tr></table></div></figure>


<p>异常的来源，居然是连接的close方法。</p>

<h3>为什么close会失败</h3>

<p>在WebSphere的资料上没有找到相关的描述，但是我在ibatis的文档上找到了相关的描述(ibatis developer guide的12-13页)：</p>

<p>The <transactionManager> element also allows an optional attribute commitRequired that can be true or
false.  Normally iBATIS will not commit transactions unless an insert, update, or delete operation has been
performed.  This is true even if you explicitly call the commitTransaction() method.  This behavior
creates problems in some cases.  If you want iBATIS to always commit transactions, even if no insert,
update, or delete operation has been performed, then set the value of the commitRequired attribute to true.
Examples of where this attribute is useful include:</p>

<ol>
<li><p>If you call a stored procedures that updates data as well as returning rows.  In that case you would
call the procedure with the queryForList() operation – so iBATIS would not normally commit the
transaction.  But then the updates would be rolled back.</p></li>
<li><p>In a WebSphere environment when you are using connection pooling and you use the JNDI
<dataSource> and the JDBC or JTA transaction manager.  WebSphere requires all transactions on
pooled connections to be committed or the connection will not be returned to the pool.</p></li>
</ol>


<p>Note that the commitRequired attribute has no effect when using the EXTERNAL transaction manager.</p>

<h3>结论及对策</h3>

<p>从上面的描述上看到，WebSphere环境的连接是需要提交事务的，否则会被意外关闭。
并且，如果选择ibatis的事务管理机制，就应该设置commitRequired属性，要么就应该使用spring的事务解决方案。</p>

<p>我们尝试给查询语句增加commit操作，果然异常信息不再出现，并且数据库连接数也大幅度减少了。
看来，在生产系统中还是应该优先考虑成熟的解决方案，不要随便造轮子。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20130630_object-balance-pool.html">带平衡的对象池设计</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-30T00:00:00+08:00" pubdate data-updated="true">Jun 30<span>th</span>, 2013</time>
        
         | <a href="/blog/20130630_object-balance-pool.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近有个需求，是关于一个Socket连接池的功能改造，要求实现下面的需求:</p>

<ol>
<li>可配置多个服务器地址</li>
<li>服务器地址可以配置权重(比如3:2:1)</li>
<li>连接池可以设置最小连接和最大连接</li>
<li>某服务器从崩溃中恢复后，连接池中的连接数可以自动恢复到服务器之间的权重比。</li>
<li>连接可设置最大空闲释放时间</li>
</ol>


<p>一开始有同事自定义了一个链表来做取数和归还的操作，在线程安全方面操作感觉还是有点麻烦。
后来我采用PriorityBlockingQueue来实现，其实就是内部变成了堆的结构。见下面的图:</p>

<p><img src="/assets/images/2013/pool/1.png" alt="数据结构" /></p>

<p><img src="/assets/images/2013/pool/2.png" alt="类图" /></p>

<p><img src="/assets/images/2013/pool/3.png" alt="状态图" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20130615_java-string-constant-pool.html">初探Java字符串</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-15T00:00:00+08:00" pubdate data-updated="true">Jun 15<span>th</span>, 2013</time>
        
         | <a href="/blog/20130615_java-string-constant-pool.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>String印象</h2>

<p>String是java中的无处不在的类，使用也很简单。初学java，就已经有字符串是不可变的盖棺定论，解释通常是:它是final的。</p>

<p>不过，String是有字面量这一说法的，这是其他类型所没有的特性(除原生类型)。另外，java中也有字符串常量池这个说法，用来存储字符串字面量，不是在堆上，而是在方法区里边存在的。</p>

<h2>字面量和常量池初探</h2>

<p>字符串对象内部是用字符数组存储的，那么看下面的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">m</span> <span class="o">=</span> <span class="s">&quot;hello,world&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">n</span> <span class="o">=</span> <span class="s">&quot;hello,world&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">u</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
</span><span class='line'><span class="n">String</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&quot;hello,world&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些语句会发生什么事情? 大概是这样的:</p>

<ol>
<li>会分配一个11长度的char数组，并在常量池分配一个由这个char数组组成的字符串，然后由m去引用这个字符串。</li>
<li>用n去引用常量池里边的字符串，所以和n引用的是同一个对象。</li>
<li>生成一个新的字符串，但内部的字符数组引用着m内部的字符数组。</li>
<li>同样会生成一个新的字符串，但内部的字符数组引用常量池里边的字符串内部的字符数组，意思是和u是同样的字符数组。</li>
</ol>


<p>如果我们使用一个图来表示的话，情况就大概是这样的(使用虚线只是表示两者其实没什么特别的关系):</p>

<p><img src="/assets/images/2013/string/string1.png" alt="对象在内存中的布局" /></p>

<p>结论就是,m和n是同一个对象，但m,u,v都是不同的对象，但都使用了同样的字符数组，并且用equal判断的话也会返回true。</p>

<p>我们可以使用反射修改字符数组来验证一下效果，可以试试下面的测试代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Test</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">m</span> <span class="o">=</span> <span class="s">&quot;hello,world&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">n</span> <span class="o">=</span> <span class="s">&quot;hello,world&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">u</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&quot;hello,world&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Field</span> <span class="n">f</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">f</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>    <span class="kt">char</span><span class="o">[]</span> <span class="n">cs</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">[])</span> <span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
</span><span class='line'>    <span class="n">cs</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="sc">&#39;H&#39;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">String</span> <span class="n">p</span> <span class="o">=</span> <span class="s">&quot;Hello,world&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">u</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面的例子可以看到，经常说的字符串是不可变的，其实和其他的final类还是没什么区别，还是引用不可变的意思。
虽然String类不开放value，但同样是可以通过反射进行修改，只是通常没人这么做而已。
即使是涉及&#8221;修改&#8221;的方法，都是通过产生一个新的字符串对象来实现的，例如replace、toLower、concat等。
这样做的好处就是让字符串是一个状态不可变类，在多线程操作时没有后顾之忧。</p>

<p>当然，在字符串修改的时候，会产生一个新的对象，如果执行很频繁，就会导致大量对象的创建，性能问题也就随之而来了。
为了应付这个问题，通常我们会采用StringBuffer或StringBuilder类来处理。</p>

<p>另外，字符串常量通常是在编译的时候就确定好的，定义在类的方法区里边，也就是说，不同的类，即使用了同样的字符串，
还是属于不同的对象。所以才需要<strong>通过引用字符串常量来减少相同的字符串的数量</strong>。可以通过下面的代码来测试一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="c1">// 修改s的第一个字符为H</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">);</span> <span class="c1">// 输出Hello</span>
</span><span class='line'>        <span class="k">new</span> <span class="nf">A</span><span class="o">().</span><span class="na">print</span><span class="o">();</span> <span class="c1">// 输出hello</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>字符串操作细节</h2>

<p>String类内部处理有个字符数组之外，还使用偏移位置offset和长度count，
通过offset和count来确定字符数组的一部分，这部分才是这个字符串的真正的内容。
例如，有substring这个常用方法，看下面的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">m</span> <span class="o">=</span> <span class="s">&quot;hello,world&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">u</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">10</span><span class="o">);</span>
</span><span class='line'><span class="n">String</span> <span class="n">v</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>按照上面的说法，m,n的数据结构就如下图所示:</p>

<p><img src="/assets/images/2013/string/string2.png" alt="substring在内存中的布局" /></p>

<p>可以发现，m,n,v是三个不同的字符串对象，但引用的value数组其实是同一个。
同样可以通过上述反射的代码进行验证，这里就不详述了。</p>

<p>但字符串操作时，可能需要修改原来的字符串数组内容或者原数组没法容纳的时候，就会使用另外一个新的数组，例如replace,concat,+等操作。另外，oracle的JDK实现中，String的构造方法，对于字符串参数只是引用部分字符数组的情况(count小于字符数组长度)，采用的是拷贝新数组的方式，是比较特别的，不过这个构造方法也没什么机会使用到。</p>

<p>例如下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">m</span> <span class="o">=</span> <span class="s">&quot;hello,&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">u</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">concat</span><span class="o">(</span><span class="s">&quot;world&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">String</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>得到的结构图如下:</p>

<p><img src="/assets/images/2013/string/string3.png" alt="新字符数组在内存中的布局" /></p>

<p>可以发现，m,u,v内部的字符数组并不是同一个，有兴趣可以试验一下。</p>

<h2>常量池中字符串的产生</h2>

<p>常量池中的字符串通常是通过字面量的方式产生的，就像上述m语句那样。
并且他们是在编译的时候就准备好了，类加载的时候，顺便就在常量池生成。</p>

<p>可以通过javap命令检查一下class的字节码，可以发现下面的高亮部分(以上面代码为例):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='diff'><span class='line'> javap -v StringTest
</span><span class='line'>
</span><span class='line'> Compiled from &quot;StringTest.java&quot;
</span><span class='line'> public class com.github.mccxj.StringTest extends java.lang.Object
</span><span class='line'>   SourceFile: &quot;StringTest.java&quot;
</span><span class='line'>   minor version: 0
</span><span class='line'>   major version: 50
</span><span class='line'>   Constant pool:
</span><span class='line'> const #1 = Method       #9.#28; //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V
</span><span class='line'><span class="gi">+ const #2 = String       #29;    //  hello,</span>
</span><span class='line'><span class="gi">+ const #3 = String       #30;    //  world</span>
</span><span class='line'> ...
</span><span class='line'><span class="gi">+ const #46 = Asciz       hello,;</span>
</span><span class='line'><span class="gi">+ const #47 = Asciz       world;</span>
</span><span class='line'> ...
</span></code></pre></td></tr></table></div></figure>


<p>大家不知有没有发现，上面的图中，u和v的字符数组没有被常量池里边的字符串引用到。
原因就是这些字符串(字符数组)都是运行时生成的，而常量池里边的字符串和字符数组是完整对应上的(count等于数组长度)。</p>

<p>即使是字符串的内容是一样的，都不能保证是同一个字符串数组。例如下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">m</span> <span class="o">=</span> <span class="s">&quot;hello,world&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">u</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">v</span> <span class="o">=</span> <span class="s">&quot;hello,world.&quot;</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>u和v虽然是一样内容的字符串，但内部的字符数组不是同一个。画成图的话就是这样的:</p>

<p><img src="/assets/images/2013/string/string4.png" alt="不同字符数组在内存中的布局" /></p>

<p>另外有一点，如果让m声明为final，你就会发现u和v变成是同一个对象。画成图的话就是这样的:</p>

<p><img src="/assets/images/2013/string/string5.png" alt="u和v在内存中的布局" /></p>

<p>这应该怎么解释的？这其实都是编译器搞的鬼，因为m是final的，
u直接被编译成&#8221;hello,world.&#8221;了，如果使用javap查看的话，会发现下面一段逻辑:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='diff'><span class='line'>const #2 = String       #25;    //  hello,world
</span><span class='line'>const #3 = String       #26;    //  hello,world.
</span><span class='line'>...
</span><span class='line'>public void test1()   throws java.lang.Exception;
</span><span class='line'>  Code:
</span><span class='line'>   Stack=1, Locals=4, Args_size=1
</span><span class='line'>   0:   ldc     #2; //String hello,world
</span><span class='line'>   2:   astore_1
</span><span class='line'>   3:   ldc     #3; //String hello,world.
</span><span class='line'>   5:   astore_2
</span><span class='line'>   6:   ldc     #3; //String hello,world.
</span><span class='line'>   8:   astore_3
</span><span class='line'>   9:   return
</span></code></pre></td></tr></table></div></figure>


<p>那么，如何让运行时产生的字符串放到常量池里边呢? 可以借助String类的intern方法。
例如下面的用法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">m</span> <span class="o">=</span> <span class="s">&quot;hello,world&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">u</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>
</span><span class='line'><span class="n">String</span> <span class="n">v</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="na">intern</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面我们已经知道m,n使用的是同一个字符数组，但intern方法会到常量池里边去寻找字符串&#8221;he&#8221;,如果找到的话，就直接返回该字符串，
否则就在常量池里边创建一个并返回，所以v使用的字符数组和m,n不是同一个。画成图的话就是这样的:</p>

<p><img src="/assets/images/2013/string/string6.png" alt="intern在内存中的布局" /></p>

<h2>字符串的内存释放问题</h2>

<p>像字面量字符串，因为存放在常量池里边，被常量池引用着，是没法被GC的。例如下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">m</span> <span class="o">=</span> <span class="s">&quot;hello,world&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">m</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'><span class="n">n</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>经过上述的操作，画成图的话就是这样的:</p>

<p><img src="/assets/images/2013/string/string7.png" alt="内存释放后的布局" /></p>

<p>而经过上面的分析，我们知道像substring、split等方法得到的结果都是引用原字符数组的。
如果某字符串很大，而且不是在常量池里存在的，当你采用substring等方法拿到一小部分新字符串之后，长期保存的话(例如用于缓存等)，
会造成原来的大字符数组意外无法被GC的问题。</p>

<p>关于这个问题，常见的解决办法就是使用new String(String original)或java.io.StreamTokenizer类。并且在网上已经有比较广泛的讨论，大家可以去阅读一下:</p>

<ul>
<li><a href="http://blog.xebia.com/2007/10/04/leaking-memory-in-java/">Leaking Memory in Java</a></li>
<li><a href="http://www.iteye.com/topic/626801">优化变成了忧患：String类的split方法引起的内存泄漏</a></li>
</ul>


<h2>结论</h2>

<ul>
<li>任何时候，比较字符串内容都应该使用equals方法</li>
<li>修改字符串操作，应该使用StringBuffer，StringBuilder</li>
<li>可以使用intern方法让运行时产生字符串的复用常量池中的字符串</li>
<li>字符串操作可能会复用原字符数组，在某些情况可能造成内存泄露的问题</li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/5/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/3/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/20131126_connection-leak.html">连接池泄露定位案例</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131120_notebook-system-install.html">周日笔记本系统安装记事</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131108_mission-estimate.html">谈任务分解与评估</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131106_jsch-session-connect.html">小心jsch的sftp连接泄露</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131103_word-contact.html">单词接龙问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131029_youdao-note.html">有道云笔记使用感受</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130930_des.html">DES加解密总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130921_books.html">那些年，我读过的技术书</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130908_redis-introduction.html">redis简报</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130901_junit-parameterized.html">JUnit参数化介绍与实践</a>
      </li>
    
  </ul>
</section>

<section>
<iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=8&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=1735848865&verifier=fa40be14&dpc=1"></iframe>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/mccxj">@mccxj</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'mccxj',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - 蔡晓建 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'mccxj';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
