
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>小毛的胡思乱想</title>
  <meta name="author" content="蔡晓建">

  
  <meta name="description" content="这是09~10年的时候弄的一份总结文档，一直存在在google docs里边。这次把它弄过来，做个见证，留个纪念。 正文 总体的，不好归类的 /media 用来挂载usb存储设备，DVD, CD-ROM等
/mnt 用来临时挂载文件系统，可插拔的设备应该挂载到/media上去
/home &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://mccxj.github.com/blog/page/13/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="小毛的胡思乱想" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">小毛的胡思乱想</a></h1>
  
    <h2>凡走过,必留痕迹.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:mccxj.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20120902_linux-config-introduction.html">Linux文件目录结构简介(旧)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-02T00:00:00+08:00" pubdate data-updated="true">Sep 2<span>nd</span>, 2012</time>
        
         | <a href="/blog/20120902_linux-config-introduction.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>这是09~10年的时候弄的一份总结文档，一直存在在google docs里边。这次把它弄过来，做个见证，留个纪念。</strong></p>

<h2>正文</h2>

<h3>总体的，不好归类的</h3>

<div class="highlight"><pre><code class="bash">/media 用来挂载usb存储设备，DVD, CD-ROM等
/mnt 用来临时挂载文件系统，可插拔的设备应该挂载到/media上去
/home 除root之外的用户目录的默认所在地
/root root用户目录
/bin 最常用的命令
/sbin 系统管理员使用的命令<span class="o">(</span><span class="nv">sbin</span><span class="o">=</span>system bin<span class="o">)</span>
/usr/local 使用源码安装的话，一般把prefix目录指定到这里，如/usr/local/ruby
/usr/share/applications desktop文件是桌面的菜单项
~/.gnome*,~/.gconf* gnome面板的个人配置信息，当gnome面板乱了，可以尝试删除这些文件来恢复默认面板
</code></pre></div>


<h3>/boot目录，kernel相关部分</h3>

<div class="highlight"><pre><code class="bash">/boot/symvers-%<span class="o">{</span>KRELEASE<span class="o">}</span>.gz 保存着内核中所有符号的crc值
/boot/System.map-%<span class="o">{</span>KRELEASE<span class="o">}</span> 给kernel使用的符号表<span class="o">(</span>symbol table<span class="o">)</span>
/boot/vmlinuz-%<span class="o">{</span>KRELEASE<span class="o">}</span> 可引导的、压缩的内核
/boot/initrd-%<span class="o">{</span>KRELEASE<span class="o">}</span>.img 包含了支持 Linux 系统两阶段引导过程所需要的必要可执行程序和系统文件
/boot/config-%<span class="o">{</span>KRELEASE<span class="o">}</span> 包括kernel的make config
/boot/message cpio格式的打包文件，存放Grub的配置信息，里面包括了图片，文字说明等内容
</code></pre></div>


<h3>/boot目录，grub配置</h3>

<div class="highlight"><pre><code class="bash">/boot/grub/menu.lst 一个链接文件，真实文件是grub.conf
/boot/grub/grub.conf grub的配置文件
/boot/grub/device.map 设备的映射文件
/boot/grub/splash.xpm.gz grub开机画面的gzip压缩包
/boot/grub/stageN 一般有stage1和stage2，是grub的核心，受限于mbr512字节的大小限制，所以切开成几个，stage1是用来加载stage2的
/boot/grub/XXX_stage1_5 stage2文件较大，一般存放于文件系统中，需要XXX_stage1_5来识别各种各样的文件系统
</code></pre></div>


<h3>/etc目录，系统用户/用户组</h3>

<div class="highlight"><pre><code class="bash">/etc/passwd 存放所有系统用户及相关信息
/etc/shadow 存放所有系统用户的密码信息
/etc/group 存放所有系统用户组及相关信息
/etc/gshadow 存放所有系统用户组的密码信息
</code></pre></div>


<h3>/etc目录，系统启动流程相关</h3>

<div class="highlight"><pre><code class="bash">/etc/issue 发行版信息
/etc/redhat-release redhat版本信息
/etc/inittab 系统初始化配置
/etc/init.d 存放服务脚本的地方
/etc/rc<span class="o">[</span>0-6S<span class="o">]</span>.d 每个运行级别对应的服务，里边的脚本都是链接到/etc/init.d目录
/etc/rc rc启动脚本
/etc/rc.local 在所有init脚本结束后调用
/etc/rc.sysinit 在系统启动时运行一次
/etc/profile 环境变量配置
/etc/profile.d 保存一些脚本，可在/etc/profile中调用
~/.bash_profile  针对某个用户的配置，会调用.bash_rc
~/.bashrc 针对某个用户的配置，会调用/etc/bashrc
/etc/bashrc 使用bash时，可设置全局环境配置
~/.bash_history  命令的历史记录
~/.bash_logout   用户退出时执行
/etc/xinetd.conf xinetd的配置文件
/etc/xinetd.d 存放xinetd服务的地方
/etc目录，基本应用配置相关
/etc/skel 存放用户文件的“骨架”，当一个用户创建的时候，里边的文件就会拷贝到相应的home目录

/etc/X11 存放X Window的系统配置文件，例如xorg.conf

/etc/DIR_COLORS ls的时候，文件/文件夹显示的颜色
/etc/mtab 记录目前挂载的文件系统信息
/etc/fastboot 由shutdown -f 所产生的 ,在重启之后, 系统会去检查这个文件是否存在以决定是否要执行fsck
/etc/nologin 系统关闭的时候自动产生，里边放着shutdown message。在这个时候如果有用户企图登录，就会打印出这个文件存放的message，然后阻止你登录

/etc/fstab 默认的文件系统挂载情况

/etc/virc vi的配置
/etc/vimrc vim的配置
/etc/wgetrc wget的配置
/etc/yum.conf yum的配置
/etc/yum.repos.d yum源的存放位置

/etc/kdump.conf kdump内核的配置文件
/etc/my.cnf mysql的配置文件
/etc/ssh ssh的配置文件目录，重要的有sshd_config
/etc/syslog.conf syslog的配置文件
/etc/updatedb.conf updatedb的配置文件
/etc/mtools.conf mtools配置，用于在*UNIX系统中直接访问dos/win文件系统
/etc/sysctl.conf sysctl预加载的配置文件
/etc/moprobe.conf modprobe的配置文件
/etc/ld.so.conf 加载动态链接库的配置文件，默认会加载ld.so.conf.d里边的配置
/etc/ld.so.conf.d 存放动态链接库的配置文件
/etc/ld.so.cache 动态链接库的缓存，二进制文件，可以通过ldconfig --print-cache查看

/etc/services 网络服务列表<span class="o">(</span>服务名,端口，协议等<span class="o">)</span>
/etc目录，域名解析，主机访问控制
/etc/host.conf  定义DNS客户端主机发出域名解析的处理顺序，默认是先查看/etc/hosts文件，再发送远程请求
/etc/hosts 自定义ip-域名解析
/etc/resolv.conf DNS服务器地址
/etc/hosts.allow 和hosts.deny一起用来作为tcpd服务器的配置文件，tcpd服务器可以控制外部IP对本机服务的访问。hosts.allow控制可以访问本机的IP地址
/etc/hosts.deny  控制禁止访问本机的IP。如果和hosts.allow的配置有冲突，以hosts.deny为准

/etc目录，定时任务控制
/etc/crontab cron任务的配置文件，一般在里边配置有cron.hourly，cron.daily，cron.weekly和cron.monthly
/etc/cron.d 如果你要在特殊的时间使用crontab，可以把配置放到文件夹里边，配置的格式和/etc/crontab一样
/etc /cron.daily 每天定时任务
/etc/cron.hourly 每小时定时任务
/etc/cron.monthly 每月定时任务
/etc/cron.weekly 每星期定时任务
/etc/cron.allow 指定那些用户可以使用crontab
/etc/cron.deny 指定哪些用户禁止使用crontab，如果文件存在且为空，所有人都可以使用，如果文件不存在，那么只有root可以使用
/etc/at.allow 指定那些用户可以使用at
/etc/at.deny 指定哪些用户禁止使用at，如果文件存在且为空，所有人都可以使用，如果文件不存在，那么只有root可以使用
</code></pre></div>


<h3>/dev目录 硬件设备信息</h3>

<div class="highlight"><pre><code class="bash">/dev/hd<span class="o">[</span>a-z<span class="o">]</span>  第几个IDE硬盘
/dev/tty<span class="o">[</span>0-9<span class="o">]</span> 第几个虚拟控制台
/dev/sd<span class="o">[</span>a-z<span class="o">]</span>  第几个SCSI或SATA硬盘
/dev/zero 一个无穷尽地提 供0<span class="o">(</span>NULL<span class="o">)</span>的设备，可以用来初始化文件
/dev/null 一个空设备，可以向它输出任何数据，而任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶
/dev/stderr  链接文件，指向/proc/self/fd/2<span class="o">(</span>标准错误<span class="o">)</span>

/dev/stdin  链接文件，指向/proc/self/fd/0<span class="o">(</span>标准输入<span class="o">)</span>
/dev/stdout 链接文件，指向/proc/self/fd/1<span class="o">(</span>标准输出<span class="o">)</span>
/dev/console 系统控制台，也就是直接和系统连接的监视器。如果你用cat查看该设备，并敲入一些内容，可以看到在屏幕上回显
/dev/fd<span class="o">[</span>0-9<span class="o">]</span> 第几个软驱设备
/dev/st SCSI磁带驱动器
/dev/pty 提供远程登陆伪终端支持。在进行Telnet登录时就要用到该设备
/dev/ttys 计算机串行接口，对于DOS来说就是com1口
/dev/cua 计算机串行接口，与调制解调器一起使用的设备
</code></pre></div>


<h3>/proc目录 虚拟文件系统</h3>

<div class="highlight"><pre><code class="bash">/proc/apm Advanced Power Management<span class="o">(</span>APM<span class="o">)</span>系统信息，与apm命令相关
/proc/buddyinfo 每个内存区中的每个order有多少块可用,和内存碎片问题有关
/proc/cmdline 启动时传递给kernel的参数信息
/proc/cpuinfo cpu的信息
/proc/crypto 内核使用的所有已安装的加密密码及细节
/proc/devices 已经加载的设备并分类
/proc/dma 已注册使用的ISA DMA频道列表
/proc/execdomains Linux内核当前支持的execution domains
/proc/fb 帧缓冲设备列表，包括数量和控制它的驱动
/proc/filesystems 内核当前支持的文件系统类型
/proc/interrupts x86架构中的每个IRQ中断数
/proc/iomem 每个物理设备当前在系统内存中的映射
/proc/ioports 一个设备的输入输出所使用的注册端口范围
/proc/kcore 代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb
/proc/kmsg 记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理
/proc/loadavg 根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关
/proc/locks 内核锁住的文件列表
/proc/mdstat 多硬盘，RAID配置信息<span class="o">(</span><span class="nv">md</span><span class="o">=</span>multiple disks<span class="o">)</span>
/proc/meminfo RAM使用的相关信息
/proc/misc 其他的主要设备<span class="o">(</span>设备号为10<span class="o">)</span>上注册的驱动
/proc/modules 所有加载到内核的模块列表
/proc/mounts 系统中使用的所有挂载
/proc/mtrr 系统使用的Memory Type Range Registers <span class="o">(</span>MTRRs<span class="o">)</span>
/proc/partitions 分区中的块分配信息
/proc/pci 系统中的PCI设备列表

/proc/slabinfo 系统中所有活动的 slab 缓存信息
/proc/stat 所有的CPU活动信息
/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可读的
/proc/uptime 系统已经运行了多久
/proc/swaps 交换空间的使用情况
/proc/version Linux内核版本和gcc版本
/proc/bus 系统总线<span class="o">(</span>Bus<span class="o">)</span>信息，例如pci/usb等
/proc/driver 驱动信息
/proc/fs 文件系统信息
/proc/ide ide设备信息
/proc/irq 中断请求设备信息
/proc/net 网卡设备信息
/proc/scsi scsi设备信息
/proc/tty tty设备信息
/proc/net/dev 显示网络适配器及统计信息
/proc/vmstat 虚拟内存统计信息
/proc/vmcore 内核panic时的内存映像
/proc/diskstats 取得磁盘信息
/proc/schedstat kernel调度器的统计信息
/proc/zoneinfo 显示内存空间的统计信息，对分析虚拟内存行为很有用
/proc目录， 进程N的信息
/proc/N pid为N的进程信息
/proc/N/cmdline 进程启动命令
/proc/N/cwd 链接到进程当前工作目录
/proc/N/environ 进程环境变量列表
/proc/N/exe 链接到进程的执行命令文件
/proc/N/fd 包含进程相关的所有的文件描述符
/proc/N/maps 与进程相关的内存映射信息
/proc/N/mem 指代进程持有的内存，不可读
/proc/N/root 链接到进程的根目录
/proc/N/stat 进程的状态
/proc/N/statm 进程使用的内存的状态
/proc/N/status 进程状态信息，比stat/statm更具可读性
/proc/self 链接到当前正在运行的进程
</code></pre></div>


<h3>/var目录 存放经常变化数据的地方</h3>

<div class="highlight"><pre><code class="bash">/var/lib/rpm 存放大多数rpm相关的文件
/var/cache/yum yum升级时下载的rpm文件的临时存放地，还包括系统中rpm包的头信息
/var/spool/cron/<span class="nv">$username</span> 每个用户自定义的cron任务，可以使用crontab或vi来操作

/var/lock 一般用来存放文件锁
/var/log 一般用来存放日志文件
/var/run 一般用来存放pid文件
/var/crash 一般是存放系统崩溃时产生的信息
/var/cache 一般用来存放缓存信息,例如yum package的缓存
</code></pre></div>


<h3>/etc/sysconfig目录 系统基本配置</h3>

<div class="highlight"><pre><code class="bash">/etc/sysconfig/amd 为amd提供操作参数，用来自动mount/unmount文件系统
/etc/sysconfig/apmd   由apmd使用来配置电源设置
/etc/sysconfig/arpwatch 在启动的时候传递给arpwatch守护进程的参数
/etc/sysconfig/authconfig 设置主机使用的验证方式
/etc/sysconfig/autofs 自动挂载设备的自定义选项
/etc/sysconfig/clock 系统硬件时钟的设置
/etc/sysconfig/desktop 设置新用户的桌面和进入运行级别5所使用的显示管理器
/etc/sysconfig/dhcpd 在启动的时候传递给dhcpd守护进程的参数
/etc/sysconfig/gpm 在启动的时候传递给gpm守护进程的参数
/etc/sysconfig/hwconf 列出kudzu检测到的所有硬件
/etc/sysconfig/i18n 默认系统语言，系统支持的所有语言，默认系统字体
/etc/sysconfig/init 系统启动时的显示方式
/etc/sysconfig/ip6tables-config  在系统启动或者ip6tables服务启动时，内核用来设置IPv6包过滤
/etc/sysconfig/iptables-config 在系统启动或者iptables服务启动时，内核用来设置包过滤
/etc/sysconfig/keyboard 控制键盘的行为
/etc/sysconfig/kudzu 在启动的时候通过kudzu触发一次安全的系统硬件探查
/etc/sysconfig/named 在启动的时候传递给named守护进程的参数
/etc/sysconfig/netdump netdump服务的配置文件
/etc/sysconfig/network 网络的配置信息
/etc/sysconfig/ntpd 在启动的时候传递给ntpd守护进程的参数
/etc/sysconfig/radvd 在启动的时候传递给radvd守护进程的参数
/etc/sysconfig/samba 在启动的时候传递给smbd/nmbd守护进程的参数
/etc/sysconfig/selinux selinux的基本控制选项
/etc/sysconfig/spamassassin 在启动的时候传递给spamd守护进程的参数
/etc/sysconfig/squid 在启动的时候传递给squid守护进程的参数
/etc/sysconfig/vncservers 配置vnc服务启动的方式
/etc/sysconfig/xinetd 在启动的时候传递给xinetd守护进程的参数
</code></pre></div>


<h3>/proc/sys目录 系统重要配置参数，涉及众多内核参数</h3>

<div class="highlight"><pre><code class="bash">/proc/sys/fs/file-max 可以分配的文件句柄的最大数目
/proc/sys/fs/file-nr 已分配文件句柄的数目、已使用文件句柄的数目、文件句柄的最大数目
/proc/sys/fs/inode-* 任何以名称“inode”开头的文件所执行的操作与上面那些以名称“file”开头的文件所执行的操作一样，但所执行的操作与索引节点有关，而与文件句柄无关
/proc/sys/fs/overflowuid 和 /proc/sys/fs/overflowgid 这两个文件分别保存那些支持 16 位用户标识和组标识的任何文件系统的用户标识（UID）和组标识（GID）
/proc/sys/fs/super-max 该文件指定超级块处理程序的最大数目。挂装的任何文件系统需要使用超级块，所以如果挂装了大量文件系统，则可能会用尽超级块处理程序
/proc/sys/fs/super-nr　显示当前已分配超级块的数目
/proc/sys/kernel/acct 该文件有三个可配置值，根据包含日志的文件系统上可用空间的数量（以百分比表示），这些值控制何时开始进行进程记帐：如果可用空间低于这个百分比值，则停止进程记帐/如果可用空间高于这个百分比值，则开始进程记帐/检查上面两个值的频率（以秒为单位）
/proc/sys/kernel/ctrl-alt-del 该值控制系统在接收到 ctrl+alt+delete 按键组合时如何反应
/proc/sys/kernel/domainname 配置网络域名
/proc/sys/kernel/hostname 主机名
/proc/sys/kernel/msgmax 指定了从一个进程发送到另一个进程的消息的最大长度
/proc/sys/kernel/msgmnb  指定在一个消息队列中最大的字节数
/proc/sys/kernel/msgmni 指定消息队列标识的最大数目
/proc/sys/kernel/panic 如果发生“内核严重错误（kernel panic）”，内核在重新引导之前等待的时间
/proc/sys/kernel/printk 该文件有四个数字值，它们根据日志记录消息的重要性，定义将其发送到何处
/proc/sys/kernel/shmall 在任何给定时刻系统上可以使用的共享内存的总量（以字节为单位）
/proc/sys/kernel/shmax 内核所允许的最大共享内存段的大小（以字节为单位）
/proc/sys/kernel/shmmni 用于整个系统共享内存段的最大数目
/proc/sys/kernel/sysrq  如果该文件指定的值为非零，则激活 System Request Key
/proc/sys/kernel/threads-max 内核所能使用的线程的最大数目
/proc/sys/net/core/message_burst 写新的警告消息所需的时间（以 1/10 秒为单位）；在这个时间内所接收到的其它警告消息会被丢弃。这用于防止某些企图用消息“淹没”您系统的人所使用的拒绝服务攻击
/proc/sys/net/core/message_cost 存有与每个警告消息相关的成本值。该值越大，越有可能忽略警告消息
/proc/sys/net/core/netdev_max_backlog  在接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目
/proc/sys/net/core/optmem_max 每个套接字所允许的最大缓冲区的大小
/proc/sys/net/core/rmem_default 接收套接字缓冲区大小的缺省值（以字节为单位）
/proc/sys/net/core/rmem_max 接收套接字缓冲区大小的最大值（以字节为单位）。
/proc/sys/net/core/wmem_default 发送套接字缓冲区大小的缺省值（以字节为单位）。
/proc/sys/net/core/wmem_max 发送套接字缓冲区大小的最大值（以字节为单位）

/proc/sys/net/ipv4/ip_forward ip转发是否生效
/proc/sys/net/ipv4/tcp_retrans_collapse 控制TCP双方窗口协商出现错误的时候的一些重传的行为。但是在老的2.6的核 <span class="o">(</span>&lt;2.6.18<span class="o">)</span>里头，这个重传会导致kernel oops，kernel panic，所以如果出现有 tcp_retrans_*样子的kernel panic，可以把这个参数给设置成0
/proc/sys/vm/buffermem 控制用于缓冲区内存的整个系统内存的数量（以百分比表示）。它有三个值，通过把用空格相隔的一串数字写入该文件来设置这三个值。用于缓冲区的内存的最低百分比/如果发生所剩系统内存不多，而且系统内存正在减少这种情况，系统将试图维护缓冲区内存的数量/用于缓冲区的内存的最高百分比
/proc/sys/vm/freepages 控制系统如何应对各种级别的可用内存。它有三个值，通过把用空格相隔的一串数字写入该文件来设置这三个值。如果系统中可用页面的数目达到了最低限制，则只允许内核分配一些内存/如果系统中可用页面的数目低于这一限制，则内核将以较积极的方式启动交换，以释放内存，从而维持系统性能/内核将试图保持这个数量的系统内存可用。低于这个值将启动内核交换
/proc/sys/vm/kswapd 控制允许内核如何交换内存。它有三个值，通过把用空格相隔的一串数字写入该文件来设置这三个值：内核试图一次释放的最大页面数目。如果想增加内存交换过程中的带宽，则需要增加该值/内核在每次交换中试图释放页面的最少次数/内核在一次交换中所写页面的数目。这对系统性能影响最大。这个值越大，交换的数据越多，花在磁盘寻道上的时间越少。然而，这个值太大会因“淹没”请求队列而反过来影响系统性能
/proc/sys/vm/pagecache 该文件与/proc/sys/vm/buffermem 的工作内容一样，但它是针对文件的内存映射和一般高速缓存
/proc/sys/vm/dirty_background_ratio 记录当所有被更改页面总大小占工作内存超过某个限制时，pdflush 会开始写回工作,默认是10%
/proc/sys/vm/dirty_ratio 控制文件系统的文件系统写缓冲区的大小，单位是百分比，表示系统内存的百分比，表示当写缓冲使用到系统内存多少的时候，开始向磁盘写出数据。默认是40%
/proc/sys/vm/dirty_writeback_centisecs 记录pdflush进程把page cache里边的内容写入磁盘的时间周期，默认是5秒
/proc/sys/vm/dirty_expire_centisecs 控制一个更改过的页面经过多长时间后被认为是过期的、必须被写回的页面，默认是30秒
/proc/sys/vm/laptop_mode 是否使用笔记本模式，在kernel2.6之后支持
</code></pre></div>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20120819_reverse-svn-diff-file.html">生成svn补丁的回退补丁</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-19T00:00:00+08:00" pubdate data-updated="true">Aug 19<span>th</span>, 2012</time>
        
         | <a href="/blog/20120819_reverse-svn-diff-file.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>生成回退补丁的脚本</h3>

<div class="highlight"><pre><code class="ruby"><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;C:/Users/peipei/Desktop/svn2.diff&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
    <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;C:/Users/peipei/Desktop/svn.diff&quot;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">ff</span><span class="o">|</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">readlines</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;@@&quot;</span><span class="p">)</span>
                <span class="n">line</span> <span class="o">=~</span> <span class="sr">/@@\ \-(.+)\ \+(.+)\ @@/</span>
                <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;@@\ \-</span><span class="si">#{</span><span class="vg">$2</span><span class="si">}</span><span class="s2">\ \+</span><span class="si">#{</span><span class="vg">$1</span><span class="si">}</span><span class="s2">\ @@</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">elsif</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;+ &quot;</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;-</span><span class="si">#{</span><span class="n">line</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">elsif</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;- &quot;</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;+</span><span class="si">#{</span><span class="n">line</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span>
                <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">line</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<h3>其他计划</h3>

<ol>
<li>在codediff工具中添加通过文件名查询功能(已经实现)</li>
<li>通过codediff工具直接生成提交补丁和回退补丁(这个延后)</li>
<li>能够支持补丁合并(这个不是那么好弄)</li>
</ol>


<h3>关于代码评审</h3>

<p>已经有个简单的方案了，我决定在codediff应用上支持每周代码评审功能，这周上线试用一下。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20120818_thought-read-jolt-book.html">书评-Jolt大奖精选丛书</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-18T00:00:00+08:00" pubdate data-updated="true">Aug 18<span>th</span>, 2012</time>
        
         | <a href="/blog/20120818_thought-read-jolt-book.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/assets/images/jolt_book.png" alt="Jolt大奖精选丛书" /></p>

<p><strong>2012-08-18@oschina.net</strong>
<a href="http://www.oschina.net/question/262659_63418?sort=default&amp;p=3#answers">书评链接</a></p>

<p><strong>这次书评活动有6本书，写书评的确花了不少时间呀！</strong></p>

<h3>《编写有效用例》书评</h3>

<p>刚毕业的时候，在公司就看到这本书，当时看了一下，不过不怎么懂。
只是隐约知道有用例这么个概念，后来慢慢地接触到业务用例，测试用例等内容，才逐渐对用例有了一些理解。
再后来，因工作需要，经常使用UML来画用例图，小人的身影更是随处可见了。直到现在，虽然用例接触有不短的时间了，
不过用例这东西还真的没有非常系统的学习过。</p>

<p>没想到过了那么多年，又重新看到这本书，倍感亲切，让我有了系统学习一下的热情。
这本书和其他软件工程书籍不大一样，因为它专注于用例的编写。里边提供了很多写用例的原则，读完可以对用例概念有深入的认识。
另外，和很多书籍不一样的是，书中使用的例子都是作者实际项目中抽取出来的，而且例子数量非常的多，我非常喜欢真实饱满的例子
，因为这样才有现实指导意义。以前看过有些书，例子是简单的傻瓜化，遇到真实的场景显得苍白无力。
这本书，实战味道比较浓烈，学到一点用一点。即使是用例方面的新手，也很容易用得上。</p>

<p>另外，我注意到一点，书中强调了项目相关人员和利益模型，梳理系统用例与业务用例的边界，这些都是以前我不曾注意或不甚理解的地方。
我非常同意一书中的一个观点：我们需要的是有用的用例，而不必是一个最好的用例。</p>

<p>的确，实践总是我们的目的，学习的过程不要忘记练习一下。
对于我来说，有了这本书，以前的实践经验更容易得到修正，以后写用例一定会更加得心应手。</p>

<h3>《代码阅读》书评</h3>

<p>据我所知，《代码阅读》这本书是这个领域唯一的著作。
这本书我曾经读过两遍，我把书中的一些实践方式用于平时工作中，感觉收获很大。</p>

<p>首先，作者提供的例子都是现实存在的代码，并不是玩具程序。这样才让书中的例子更具说服力，作者提供的操作手法也更有借鉴意义。
例如我现在手头上的项目，不包括页面光java的代码就超过100w，还有数百万的c++代码，这些代码经历了很多人的摧残。
到现在，作为一个开发人员，每天都要面对着这么多代码，在这些代码上打转，努力去修复问题，添加新特性，
还需要每日和每周做code review，保证代码质量。阅读代码的能力显得格外重要，
因此我特别喜欢第6章和第9章关于大项目和架构方面的内容，让我有信心对付这些大块头项目。</p>

<p>另外，源代码开放活动已经成为软件业不可或缺的力量，而且现在成熟稳定的开源项目日益真多，每个人或多或少都会有所涉及。
一方面工作上的项目经常使用了这些开源代码，有时候出现问题需要定位，另一方面，通过开源代码，可以学习新的架构，
编程思想，优秀开发的技巧和经验，从而提高自己的能力。无论是什么样的情况，阅读开源代码是很有必要的。
而这本书，提供了阅读代码的最佳实践，能够帮助我们更快的理解这些代码。</p>

<p>当然，这本书不单单教导如何去阅读代码。我认为，书中关于编码规范，命名方式，文档方面的内容，从代码阅读的角度，
提出了自己的看法，所以当你进行编码规范规范制定等工作的时候，有一定的指导意义。如果你想立马学习代码阅读的技巧，
作为过来人，我觉得开头先研习一下书中第10章关于代码阅读工具的内容是个不错的开始，有工具的支持，边学习边操作，
理解书中的代码阅读技巧也会跟容易一些，乐趣也就多一些了。</p>

<h3>《持续集成：软件质量改进和风险降低之道》书评</h3>

<p>真正接触持续集成是2年前来到新公司的时候，那个时候公司请了ThoughtWork公司的咨询顾问来。
顾问给我们灌输了持续集成的概念，并使用CruiseControl帮助我们搭建了持续集成环境。
随着时间的推移，我们这里多个项目组都加入了持续集成的环境，并搬来了大电视让整个过程可视化，
并加了一些警示的声音，效果很是震撼呀。持续集成是个有趣的东西，
还制定了相应的军规：红灯停，绿灯行，黄灯停一停。(和电视上显示的项目状态的颜色有关)</p>

<p>正如书上说描述的，持续集成减少重复的过程，把编译，集成测试，部署等环节自动化，
的确节省了我们的时间，并避免了人工干预的风险。另外，我们在持续集成里边加入单元测试，
findbugs，checkstyle, cppunit等测试项，这样代码质量问题可以得到更快更好的反馈，经常因为有些问题代码被快速检测出来而感到庆幸。</p>

<p>样章只有持续测试这一章节的描述，项目的可靠性必须得通过持续不断的测试来保证。
正因为如此，我们在持续集成里边加入单元测试等功能之外，还使用自动化测试用例进行测试，
当然因为测试用例巨大，耗时较长，我们通常是选择在晚上进行的。</p>

<p>按照我们的理解，对项目有利的东西，只要能够自动化，都可以考虑加入持续集成，这将给项目带来更多的好处。</p>

<h3>《代码质量》书评</h3>

<p>工作了这么多年，也接触过各式各样的系统，看过千奇百怪的代码，知道代码质量的重要性对我们是多么的重要。
每每想起那些可怕的错综复杂的代码，还有那些线上千奇百怪的问题，总会深深感到不安，实在太让人揪心了。
所以在日常工作中，我非常强调代码质量，用各种培训去提升开发人员的技能水平，用代码评审等手段试图保证代码质量。</p>

<p>现今随着硬件成本的降低，人力成本的提升，我平时考察考察代码质量多从可读性，可维护性，性能的角度出发，
正因为如此，Diomidis Spinellis这本书的目录让我眼前一亮，它从多个维度考察代码质量，
讨论了如何满足非功能性需求，我从未用如此全面的角度衡量代码的质量，的确充实了我的知识库，
让我在平时工作中用更全面的眼光衡量代码的质量。</p>

<p>另外，和代码阅读一样，书中的丰富的例子来源于现实代码，让作者的观点更具说服力。
最近团队来了不少新员工，在代码质量控制方面花了不少功夫。有时候，他们并不理解代码质量的重要性，认为代码能运行就可以了。
让新员工理解这些非功能性需求的重要性，能够在平时中注意考虑非功能性需求的，这都是非常重要而且非常迫切的需求。
我想，借助于这本书理论与实践的结合， 继续这项工作更有信心了。</p>

<h3>《面向对象分析与设计》书评</h3>

<p>这是一本关于面向对象分析与设计的书籍，通常和对象打交道的书，几乎都是在写设计模式一样，
当我看到这本书的时候，第一反应就是这样。因为我使用面向对象语言进行开发设计已经有一段时间了，
除了设计模式方面的书籍，真的很少碰到面向对象方面让人耳目一新的著作。但在浏览了书本的目录和前言部分之后，
我对这本书有另外一个感觉: 这是学习掌握UML的一本绝佳的书籍。正是这一点吸引我继续阅读下去。</p>

<p>本身作者Grady Booch就是UML的创始人之一，书中也有大量关于UML图的内容，由他使用UML来讲述再好不过了。
另外，UML里边类图，状态图等，本质上也离不开面向对象理论的支持。理论与实践相结合，这是很多书籍做不到的地方，
也是我感觉使用面向对象进行分析设计经常遇到困难的痛处。所以，即使我使用面向对象进行设计开发，
也用过UML画过各式各样的图，但书中的内容仍然吸引着我。</p>

<p>这本书提供的样章相当的多，阅读花了不少时间。书中介绍了面向对象的各种概念，
并运用了大量的例子展示了面向对象设计的经验技巧，这些都是很难描述清楚的东西，
而且容易变得很枯燥的东西，庆幸的是，作者在这方面的文笔相当好，阅读起来非常顺畅。</p>

<h3>《灾难拯救：让软件项目重回轨道 》书评</h3>

<p>终于看完这本书的样章了！我不是一个项目管理人员，但我觉得了解一些项目方面的东西是有好处的。
我面对的也是一个不是很顺利的项目，有着比较纠结的代码基，人员众多而且人员流动也比较大，线上问题也时不时的出现。
虽然采用了一些敏捷开发的手段控制进度，但也不是特别的顺利。要命的是，这是一个需要长期维护发展的关键项目，不能随意推到重来。</p>

<p>我认为这本书对于我们这种类型项目来说，还是有相当的指导意义的 。
如前言说的，这是一本救治之书，它探讨了像我们这种随时面临失败的项目，如何去拯救，如何重回正轨。
书中提到面临失败项目，实施拯救需要的10个步骤。很显然，有些步骤我们已经在现实中采用了，
并且也取得了一些成果：例如确定最低目标，风险分析等内容。但能够完整描述这些步骤，
也真的是不容易做到，有了这本书的指导，我相信实施这些步骤是具有可操作性的。</p>

<p>整本书有一个顺序脉络在那里，就是步骤的描述，所以应该从头到尾的读会比较合适，因为每个步骤是有一些关联的，
如果跳来跳去，可能不能深入理解步骤的真正意义。最后一章是整本书的总结，把前面描述的10个步骤整合在一起，
并对时间安排，实施拯救计划进行指导。对于担心书中描述的理论是否可行的人来说，
这章无疑是打了强心针一样，只要按照书中的建议进行操作，应该是能够验证效果的，需要的只是：行动。</p>

<h2>&#8220;书评&#8221;系列文章:</h2>


<ul>
 
  
  <li><a href="/blog/20120815_thought-read-javascript-idea.html">2012-08-15 书评-JavaScript语言精髓与编程实践</a></li>
  
 
  
  <li><a href="/blog/20120815_thought-read-node-web-development.html">2012-08-15 书评-Node Web开发</a></li>
  
 
  
  <li>2012-08-18 书评-Jolt大奖精选丛书</li>
  

</ul>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20120815_thought-read-node-web-development.html">书评-Node Web开发</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-15T00:00:00+08:00" pubdate data-updated="true">Aug 15<span>th</span>, 2012</time>
        
         | <a href="/blog/20120815_thought-read-node-web-development.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/assets/images/node_web_development.jpg" alt="Node Web开发" /></p>

<p><strong>2012-05-10@oschina.net</strong>
<a href="http://www.oschina.net/question/244461_53105?sort=default&amp;p=2#answers">书评链接</a></p>

<p>这本书，其实我是看的英文版的。算是一本不错的入门书，相对于官网上那硬邦邦的api手册，
的确是很不错了，里边有些内容有点旧了(例如npm介绍中关于require.path的说法)。
书里边关于node的模块系统的描述是比较好的，非常清晰，是我觉得写得最好的一章，
另外关于node的异步编程模型的介绍也比较好(例如有个关于Fibonacci数列的例子)，
因为最重要就是理解编程模型，即使很多人熟悉客户端javascript编程，
但是刚刚开始node的javascript编程，就会感到非常纠结。</p>

<p>书里边也引用了一些现有比较出名的开源库，例如express和connect，用来构建web应用。
关于这个，我觉得没什么必要，因为这两个库的在线帮助文档是做得非常好的。
我更感兴趣的是书里边一些step by step的demo，可以比较清晰得看到关键的代码是如何实现的。</p>

<p>总体来说，这书是一本不错的入门书，内容少不是问题，
比较现在还没有关于node的更多最佳实践的资料，而且node关注的就是高访问量，小请求，
业务逻辑较少，快响应的特殊场景，需要关注的领域并不是很多，
写得太多反而会埋没重点。有兴趣的同学，真的值得一看。</p>

<h2>&#8220;书评&#8221;系列文章:</h2>


<ul>
 
  
  <li><a href="/blog/20120815_thought-read-javascript-idea.html">2012-08-15 书评-JavaScript语言精髓与编程实践</a></li>
  
 
  
  <li>2012-08-15 书评-Node Web开发</li>
  
 
  
  <li><a href="/blog/20120818_thought-read-jolt-book.html">2012-08-18 书评-Jolt大奖精选丛书</a></li>
  

</ul>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20120815_thought-read-javascript-idea.html">书评-JavaScript语言精髓与编程实践</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-15T00:00:00+08:00" pubdate data-updated="true">Aug 15<span>th</span>, 2012</time>
        
         | <a href="/blog/20120815_thought-read-javascript-idea.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/assets/images/javascript_idea.jpg" alt="JavaScript语言精髓与编程实践" /></p>

<p><strong>2012-06-03@oschina.net</strong>
<a href="http://www.oschina.net/question/262659_55044?sort=default&amp;p=3#answers">书评链接</a></p>

<p>周老师这本书的第一版我是看过的，虽然我已经是有好些年工作经验的人，
在js方面也下过功夫。但读到这本书的时候，还是有豁然开朗的感觉，
是国内少有的非常有深度的书，内容涉及的知识面非常广，足见周老师功力深厚。</p>

<p>首先，我必须得强调一下，这本书不是入门级的，即使你使用过js有些年头了，还是会有所收获的。
另外，有本书名类似的叫&#8221;javascript语言精髓&#8221;的书，同样也是非常棒的书，相对来说，
两本书虽然都是说javascript，但周老师的书涉及的面更广，更偏重实践设计思想。
放出来的几个章节，是靠前的章节,主要是javascript的基础方面的内容。
但是和以往很多书不一样的是，它采用了不同的描述方式，读起来没有死气沉沉的感觉，
同时也不失重点，倍感亲切。</p>

<p>现在主要都是使用浏览器端js，关注的也主要是效果的实现，
所以很多初学者以为BOM就是javascript(我们公司很多新人就经常有误解)，这真是误入歧途呀。
这本书的内容并没有着重涉及BOM方面的具体操作，更多的时候把javascript的精华部分呈现出来，
这的确是有很多好处的，知道原理是非常重要的。</p>

<p>其实，更精彩的时候后面的章节(关于企业级,框架设计方面的内容)，
不知道第二版和第一版在这些内容上有什么变化。如果想要使用javascript做大规模应用，做框架，
或者理解现在流行的框架，这部分的内容肯定是非常有启发的，里边有很多思路，
注意的要点，周老师都有自己的见解，值得期待。
另外，我还非常关注ECMAScript新版本的内容，还有html5，服务端js相关的内容，
不知第二版有没有涉及这方面的内容,非常期待作者在这方面的的独到见解。</p>

<p>最后，我有点小建议，新书书评的时候，能不能把书的目录贴出来一下:)</p>

<h2>&#8220;书评&#8221;系列文章:</h2>


<ul>
 
  
  <li>2012-08-15 书评-JavaScript语言精髓与编程实践</li>
  
 
  
  <li><a href="/blog/20120815_thought-read-node-web-development.html">2012-08-15 书评-Node Web开发</a></li>
  
 
  
  <li><a href="/blog/20120818_thought-read-jolt-book.html">2012-08-18 书评-Jolt大奖精选丛书</a></li>
  

</ul>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/14/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/12/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/20131103_word-contact.html">单词接龙问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131029_youdao-note.html">有道云笔记使用感受</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130930_des.html">DES加解密总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130921_books.html">那些年，我读过的技术书</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130908_redis-introduction.html">redis简报</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130901_junit-parameterized.html">JUnit参数化介绍与实践</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130821_soduku-generate.html">数独随机生成探讨</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130821_java-hell-stream-close.html">从流关闭说起</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130809_java-hell-string-append.html">说说字符串拼接</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130809_java-hell-split.html">关于split的坑</a>
      </li>
    
  </ul>
</section>

<section>
<iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=8&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=1735848865&verifier=fa40be14&dpc=1"></iframe>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/mccxj">@mccxj</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'mccxj',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - 蔡晓建 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'mccxj';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
