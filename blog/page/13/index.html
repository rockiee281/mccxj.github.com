
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>小毛的胡思乱想</title>
  <meta name="author" content="蔡晓建">

  
  <meta name="description" content="这是为了oracle培训而编制的思维导图 可以在Dropbox上下载到这个xmind文件 ">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://mccxj.github.com/blog/page/13/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="小毛的胡思乱想" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">小毛的胡思乱想</a></h1>
  
    <h2>凡走过,必留痕迹.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:mccxj.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20121120_oracle-explain-plan.html">Oracle执行计划思维导图</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-11-20T00:00:00+08:00" pubdate data-updated="true">Nov 20<span>th</span>, 2012</time>
        
         | <a href="/blog/20121120_oracle-explain-plan.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2><strong>这是为了oracle培训而编制的思维导图</strong></h2>

<h2>可以在Dropbox上下载到这个<a href="https://www.dropbox.com/s/8l53i0h3hphm5bz/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.xmind">xmind文件</a></h2>

<p><img src="/assets/images/explain_plan.png" alt="oracle执行计划思维导图" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20121120_how-to-share.html">关于分享</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-11-20T00:00:00+08:00" pubdate data-updated="true">Nov 20<span>th</span>, 2012</time>
        
         | <a href="/blog/20121120_how-to-share.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>分享好处多多</h2>

<p>通过做一些分享活动，一方面可以扩大自己的影响力，让更多的人知道你。
另外一方面，可以加深自己对知识的理解，在交流中纠正一些错误的理解。
还可以提高自己的表达能力。可以说，除了需要花时间准备之外，分享对自己来说，几乎是百利而无一害的。</p>

<h2>参与度与氛围</h2>

<p>自己做分享，总是希望有更多的人来参与，并从中营造一个愉悦的氛围，
互惠互利，从中可以学习到更多。但是，经常遇到的事实是，参与的童鞋常常不愿意发言。
一方面是可能是自己不擅长，更多看成是培训，而不是交流活动，害怕犯错。还有就是，
他们没有事先做一些准备，对内容理解不够快，所以也没什么特别的疑问。
我认为，提出一些低级问题，并不是什么丢人的事情，可能是分享人没有照顾到你(经常是一类人)，
如果你不提出来的话，或许分享人会自认为大家都很明白。总之，参与一些分享活动，能全身心
投入，收获会更大。</p>

<h2>敢于分享</h2>

<p>很多童鞋都害怕分享，总是担心自己水平不够，准备不够充分，所以一拖再拖。
以我的经验，分享的内容你刚刚够得着就可以了，因为你准备的过程中，会对自己掌握的内容进行
筛选，收集更多的资料，然后进行浓缩总结，到最后你把它分享给其他人，整个过程下来，就是一次很好的
锻炼机会。不要太担心做不好，即使有些地方自己说不清，但或许经过众人的讨论，理解得就更好了。
还有就是，什么都要计划，给自己的分享计划加个合理的期限吧，少许的压力能让你做得更好。</p>

<h2>节奏与时间</h2>

<p>每次分享的时间不要过长，我就犯过这样的错误，到后面很多人都开始走神了。
还有就是，主题要比较单一，免得铺开太大，不好收缩，影响时间和效果。
时间比较长的话，中间可以适当休息一下。</p>

<h2>想不到的收获</h2>

<p>最近做了一次关于oracle执行计划的分享活动，说实话，我对这个主题不是很熟悉。
但是我觉得这东西很有用，也非常适合团队里的童鞋，所以花了几个星期的时间收集资料，
最后做了这么一个分享活动。经自己讲解了一遍，自己对这些知识加深了理解。更让我想不到的事情就是，
有其他项目组的童鞋遇到了相关的问题，跑来跟我讨论(哥俨然是专家啦)。正因为这样，我才有机会遇到更多现实的问题，
从而促进我对这些东西的理解，如果没有这次分享，有些东西可能就没法用在实践上了。
我想，很多高手也是这么炼成的。:)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20121111_javacore.html">Javacore入门介绍</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-11-11T00:00:00+08:00" pubdate data-updated="true">Nov 11<span>th</span>, 2012</time>
        
         | <a href="/blog/20121111_javacore.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>什么是javacore</h2>

<ul>
<li>javacore是java应用程序在某个时间点的<strong>线程转储文件</strong>，通常也称为<strong>Thead Dump</strong></li>
<li>记录了整个JVM的运行情况(线程, 垃圾回收, JVM运行参数, 内存地址等信息)</li>
<li>用来诊断程序问题,其中比较典型的包括线程阻塞, CPU使用率过高, JVM Crash, 堆内存不足和类装载等问题</li>
</ul>


<h2>文件命名方式</h2>

<p>javacore文件通常以txt方式结尾,名称格式主要是以javacore开头, <strong>加上日期,产生的时间,当时的线程编号</strong>,如javacore.20100719.003424.299228.txt(<strong>Unix</strong>)</p>

<h2>javacore获取方式</h2>

<ul>
<li>发送中断signal<br/>
AIX和Linux: SIGQUIT, <strong>kill -3 PID</strong><br/>
Windows: Ctrl+Break, DrAdmin in WAS(未验证过)</li>
<li>在java的执行代码中使用JavaDump()方法(未验证过)<br/>
com.ibm.jvm.Dump.javaDump()方法促使JVM dump<br/>
发布ProblemDiagnosticsLabToolkit应用包,通过可视化页面直接生成相关文件</li>
<li>系统在异常时自动throw(<strong>程序不一定退出</strong>)<br/>
严重的本地调用出错<br/>
内存不足(例如 OutOfMemory)</li>
</ul>


<h2>javacore基本内容</h2>

<p><img src="/assets/images/javacore1.jpg" alt="javacore基本内容" /></p>

<ul>
<li>操作系统相关信息JDK版本信息<br/>
关注jdk的版本(1.5前后差别比较大),32位和64位在内存要求上也有区别</li>
<li>JVM的启动参数信息<br/>
关注一些特殊的虚拟机参数如xms,xmx,xss,java.ext.dirs等，特别是内存分配要和线程数匹配，避免xms太小(频繁gc和扩展)</li>
<li>JVM堆内存信息,已装载入的类信息<br/>
JIT Core Cache和JIT Data Cache是JIT编译器使用的，用于提高运行效率。一般关注Object(Reversed)(堆内存分配)和Class(用于类加载)的内存使用率</li>
<li>dump产生原因与时间<br/>
用于追溯当时的现状</li>
<li>GC记录<br/>
关注Full GC(Global GC)情况,通常伴随比较多的GC线程</li>
<li>所有Thread执行情况(包括应用程序内部执行线程,容器线程,垃圾回收线程,定时线程,线程池线程,页面请求转发线程等多种线程信息)</li>
</ul>


<h2>线程状态分类</h2>

<p><img src="/assets/images/javacore2.png" alt="线程状态分类" /></p>

<p>整个图包括三部分，左边是线程列表，选择某个线程后，中间会展示该线程与其他线程的等待依赖关系，右边会显示线程的详细堆栈信息。
通过在线程列表中对Name,State,Stack几列进行排序，可以对每类线程数量、是否有明显的瓶颈有个大概的印象，便于接下来的具体分析。</p>

<ul>
<li>死锁 Deadlock<br/>
多个线程竞争多个资源，出现相互等待资源又不释放资源的情况，这种情况在现实中并不多见。</li>
<li>执行中 Runnable<br/>
通常这类线程堆栈真处于发送数据，数值计算，类型转换等操作。</li>
<li>等待资源 Waiting on condition<br/>
等待资源，如果堆栈信息明确是应用代码，则证明该线程正在等待资源，一般是大量读取某资源，且该资源采用了资源锁的情况下，
线程进入等待状态，等待资源的读取。又或者，正在等待其他线程的执行等</li>
<li>等待监控器检查资源 Waiting on monitor</li>
<li>暂停 Suspended</li>
<li>对象等待中 Object.wait()</li>
<li>阻塞 Blocked<br/>
线程阻塞，是指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，
可以理解为等待资源超时的线程。这种情况在was的日志中，一般可以看到CPU饥渴，或者某线程已执行了XX秒的信息</li>
<li>停止 Parked</li>
</ul>


<h3>常见的线程分类</h3>

<table markdown="1" class="table">
  <tr><td>Thread开头</td><td>一般是应用自己起的后台线程，或者自己搞的线程池(没有重命名的时候),如果是独立进程大多业务都跑在这里</td></tr>
  <tr><td>WebContainer</td><td>was容器线程，was的话业务一般都在这里，受容器线程数量控制</td></tr>
  <tr><td>Timer</td><td>Timer定时任务，一些连接池等用于监控池内对象</td></tr>
  <tr><td>Quartz</td><td>Quartz用于定时任务的线程，不受容器控制</td></tr>
  <tr><td>Finalizer</td><td>用于实现finalize特殊方法的线程</td></tr>
  <tr><td>GC Slave</td><td>GC线程，频繁gc的时候会出现不少</td></tr>
  <tr><td>Main</td><td>主线程</td></tr>
  <tr><td>JIT</td><td>用于实现JIT的线程</td></tr>
</table>


<h2>相关工具与资料</h2>

<h2>策略分析</h2>

<ul>
<li>数百K的纯文本,最好借助工具,例如jca分析工具</li>
<li><strong>采集连续的多个时间点的javacore,方便对比(手动)</strong><br/>
一般的线程执行都会非常快，如果出现某个资源的阻塞，在短时间内的两个javacore，该线程的堆栈会变化不大。
或多次javacore的线程都集中在等待某些资源。</li>
<li>了解app的性质,基本处理流程</li>
<li>app相关的处理能力(以前的数据,用于对比)</li>
<li>问题出现时,多了解周边情况(cpu,io,外围),记录现状</li>
<li><strong>对thread状态进行分类,业务分布情况,资源等待情况(细化)</strong></li>
<li>如有必要,获取heapdump分析(oom)</li>
</ul>


<h2>javacore和heapdump的区别</h2>

<p>javacore经常和heapdump联系在一起，有时候也一起出现。这里简单对两个文件进行对比，希望大家有个印象：</p>

<table markdown="1" class="table">
  <tr><td></td><td>heapdump</td><td>javacore</td></tr>
  <tr><td>文件类型</td><td>二进制</td><td>文本</td></tr>
  <tr><td>分析工具</td><td>Heap Analyzer</td><td>jca</td></tr>
  <tr><td>文件内容</td><td>内存映射 对象占用信息</td><td>CPU执行信息,线程堆栈</td></tr>
  <tr><td>作用</td><td>分析内存泄漏 大对象</td><td>分析进程挂死,响应速度慢,大对象</td></tr>
  <tr><td>影响</td><td>对系统影响大,生成文件大,较少使用</td><td>对系统影响小,生成文件小,比较方便</td></tr>
</table>


<h2>相关工具与资料</h2>

<ul>
<li>javacore-tutorial.pdf 出自IBM的文档</li>
<li>jca  javacore分析工具</li>
<li>heap analyzer  heapdump分析工具</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20121017_reflection-in-java.html">Reflection in Java</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-17T00:00:00+08:00" pubdate data-updated="true">Oct 17<span>th</span>, 2012</time>
        
         | <a href="/blog/20121017_reflection-in-java.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>什么是反射</h2>

<p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；
对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用
对象方法的功能成为java语言的反射机制。</p>

<h2>典型应用</h2>

<ul>
<li>spring生成Bean对象</li>
<li>struts2使用配置进行对象校验</li>
<li>hibernate,ibatis进行数据库对象映射</li>
<li>xml与java对象的相互转化</li>
<li>springmvc进行方法参数注入</li>
<li>more&#8230;&#8230;</li>
</ul>


<h2>理解类型</h2>

<h3>原型类型vs包装类型(XXX.TYPE)</h3>

<div class="highlight"><pre><code class="java"><span class="n">Void</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="o">-&gt;</span> <span class="n">V</span>
<span class="n">Byte</span> <span class="o">-&gt;</span> <span class="kt">byte</span> <span class="o">-&gt;</span> <span class="n">B</span>
<span class="n">Character</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="o">-&gt;</span> <span class="n">C</span>
<span class="n">Short</span> <span class="o">-&gt;</span> <span class="kt">short</span> <span class="o">-&gt;</span> <span class="n">S</span>
<span class="n">Integer</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">I</span>
<span class="n">Long</span> <span class="o">-&gt;</span> <span class="kt">long</span> <span class="o">-&gt;</span> <span class="n">J</span>
<span class="n">Float</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">F</span>
<span class="n">Double</span> <span class="o">-&gt;</span> <span class="kt">double</span> <span class="o">-&gt;</span> <span class="n">D</span>
<span class="n">Boolean</span> <span class="o">-&gt;</span> <span class="kt">boolean</span> <span class="o">-&gt;</span> <span class="n">Z</span>
</code></pre></div>


<h3>类与接口</h3>

<ul>
<li>接口(Interface)是一种特殊的类</li>
<li>注解(Annotation)是一种特殊的接口</li>
<li>枚举(Enum)是一种特殊的类</li>
</ul>


<div class="highlight"><pre><code class="java"><span class="kd">class</span> <span class="nc">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="c1">//类</span>
<span class="kd">class</span> <span class="nc">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">AbstractList</span> <span class="c1">//抽象类</span>
<span class="kd">interface</span> <span class="nc">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Runnable</span> <span class="c1">//接口</span>
</code></pre></div>


<h3>数组类型</h3>

<div class="highlight"><pre><code class="java"><span class="c1">//基本类型数组</span>
<span class="kt">int</span><span class="o">[].</span><span class="na">class</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">I</span>
<span class="kt">int</span><span class="o">[][].</span><span class="na">class</span> <span class="o">-&gt;</span> <span class="o">[[</span><span class="n">I</span>

<span class="c1">//普通类型数组</span>
<span class="n">String</span><span class="o">[].</span><span class="na">class</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">Ljava</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">;</span>
<span class="n">Integer</span><span class="o">[][].</span><span class="na">class</span> <span class="o">-&gt;</span> <span class="o">[[</span><span class="n">Ljava</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Integer</span><span class="o">;</span>
</code></pre></div>


<h2>理解类型判断方法</h2>

<div class="highlight"><pre><code class="java"><span class="c1">//是否某个类型的实例</span>
<span class="n">i</span> <span class="k">instanceof</span> <span class="n">Integer</span>
<span class="n">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isInstance</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="n">Person</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isInstance</span><span class="o">(</span><span class="k">new</span> <span class="n">SuperTeacher</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">))</span>

<span class="c1">//是否数组</span>
<span class="n">x</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">isArray</span><span class="o">()</span>

<span class="c1">//是否父子类/接口关系</span>
<span class="n">Number</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>

<span class="c1">//是否原型类型</span>
<span class="n">i</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">isPrimitive</span><span class="o">()</span>
<span class="n">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isPrimitive</span><span class="o">()</span>
<span class="n">Integer</span><span class="o">.</span><span class="na">TYPE</span><span class="o">.</span><span class="na">isPrimitive</span><span class="o">()</span>

<span class="c1">//是否注解</span>
<span class="n">Logger</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAnnotation</span><span class="o">()</span>

<span class="c1">//是否枚举</span>
<span class="n">Status</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isEnum</span><span class="o">()</span>

<span class="c1">//是否接口</span>
<span class="n">List</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isInterface</span><span class="o">()</span>
</code></pre></div>


<h2>理解修饰符</h2>

<ul>
<li>手段:Class#getModifiers()和Modifier工具类</li>
<li>适用于Class,Method,Field,Constructor</li>
</ul>


<p>示例代码如下:</p>

<div class="highlight"><pre><code class="java"><span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">Teacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">();</span>
<span class="n">assertTrue</span><span class="o">(</span><span class="n">Modifier</span><span class="o">.</span><span class="na">isPublic</span><span class="o">(</span><span class="n">mod</span><span class="o">));</span>
</code></pre></div>


<p>常见的修饰符判断方法有:</p>

<div class="highlight"><pre><code class="java"><span class="c1">//可见性</span>
<span class="n">isPublic</span><span class="o">,</span><span class="n">isProtected</span><span class="o">,</span><span class="n">isPrivate</span>
<span class="c1">//类型属性相关</span>
<span class="n">isInterface</span><span class="o">,</span><span class="n">isAbstract</span><span class="o">,</span><span class="n">isFinal</span><span class="o">,</span><span class="n">isStatic</span>
<span class="c1">//特殊作用</span>
<span class="n">isSynchronized</span><span class="o">,</span><span class="n">isNative</span><span class="o">,</span><span class="n">isTransient</span><span class="o">,</span><span class="n">isVolatile</span>
</code></pre></div>


<h2>理解类型关系</h2>

<div class="highlight"><pre><code class="java"><span class="c1">//类-&gt;父类(单继承,只有一个)</span>
<span class="n">Class</span><span class="err">#</span><span class="n">getSuperclass</span><span class="o">()</span>

<span class="c1">//类、接口-&gt;实现接口(多继承,可能有多个)</span>
<span class="n">Class</span><span class="err">#</span><span class="n">getInterfaces</span><span class="o">()</span>

<span class="c1">//类-&gt;内部类(可能有多个)</span>
<span class="n">Class</span><span class="err">#</span><span class="n">getDeclaredClasses</span><span class="o">()</span>

<span class="c1">//内部类-&gt;外部类(只有一个)</span>
<span class="n">Class</span><span class="err">#</span><span class="n">getEnclosingClass</span><span class="o">()</span>
</code></pre></div>


<h3>相关练习</h3>

<ul>
<li>Test:输出某个类实现的所有接口</li>
<li>Test:输出某个类实现的继承结构</li>
<li>Test:能够获取到之类的信息么?</li>
</ul>


<h2>理解对象生成与调用</h2>

<h3>对象生成</h3>

<p>可以采用无参数构造方法或有参数方式</p>

<div class="highlight"><pre><code class="java"><span class="c1">//需要存在无参构造方法</span>
<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;com.xxx.Student&quot;</span><span class="o">;</span>
<span class="n">Class</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="n">Teacher</span> <span class="n">teacher</span> <span class="o">=</span> <span class="o">(</span><span class="n">Teacher</span><span class="o">)</span><span class="n">t</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>

<span class="c1">//直接调用构造方法</span>
<span class="n">Constructor</span><span class="o">[]</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">SuperTeacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getConstructors</span><span class="o">();</span>
<span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">cons</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">newInstance</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">);</span>
</code></pre></div>


<h3>获取成员</h3>

<p>成员一般指Field,Method,Constructor等信息</p>

<div class="highlight"><pre><code class="java"><span class="c1">//属性</span>
<span class="n">Field</span><span class="o">[]</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">Teacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredFields</span><span class="o">();</span>
<span class="n">Field</span><span class="o">[]</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">Teacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getFields</span><span class="o">();</span><span class="c1">//只有公有的</span>

<span class="c1">//方法</span>
<span class="n">Medhod</span><span class="o">[]</span> <span class="n">ms</span> <span class="o">=</span> <span class="n">Teacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredMethods</span><span class="o">();</span>
<span class="n">Medhod</span><span class="o">[]</span> <span class="n">ms</span> <span class="o">=</span> <span class="n">Teacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getdMethods</span><span class="o">();</span><span class="c1">//只有公有的</span>

<span class="c1">//构造方法</span>
<span class="n">Constructor</span><span class="o">[]</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">Teacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructors</span><span class="o">();</span>
<span class="n">Constructor</span><span class="o">[]</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">Teacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getConstructors</span><span class="o">();</span><span class="c1">//只有公有的</span>
</code></pre></div>


<p>获取成员可以通过参数直接定位,以属性和方法为例:</p>

<div class="highlight"><pre><code class="java"><span class="n">SuperTeacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getField</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">);</span>

<span class="n">SuperTeacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&quot;setBounds&quot;</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">TYPE</span><span class="o">);</span><span class="c1">//参数是int</span>
<span class="n">SuperTeacher</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&quot;setBounds&quot;</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span><span class="c1">//参数是Integer</span>
</code></pre></div>


<p>相关练习
* Test:找到某个类所有的非private的普通方法</p>

<h3>调用方式</h3>

<p>拿到成员之后，就可以进行调用了。像Field需要使用get/set方法，
Method使用invoke方法，Constructor使用newInstance方法。如：</p>

<div class="highlight"><pre><code class="java"><span class="n">Field</span><span class="err">#</span><span class="n">set</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
<span class="n">Field</span><span class="err">#</span><span class="n">get</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>

<span class="n">Method</span><span class="err">#</span><span class="n">invoke</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</code></pre></div>


<p>有时候需要绕过可见性进行调用，需要通过setAccessible方法进行处理，如</p>

<div class="highlight"><pre><code class="java"><span class="n">Field</span><span class="err">#</span><span class="n">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span><span class="c1">// if not set, fail</span>
</code></pre></div>


<p>对于参数数组的话，通过args并不能区分是数组类型还是不定参数类型(都是通过数组进行传递)。
如果需要继续区别，应该对Method进行检测，检测方式是Method#isVarArgs</p>

<h3>处理返回值</h3>

<p>对于方法调用，可以对返回值进行处理。即使返回为void或数组类型也是可以识别的。如:</p>

<div class="highlight"><pre><code class="java"><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">returnType</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">();</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="kt">void</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">returnType</span><span class="o">);</span>
<span class="n">assertTrue</span><span class="o">(</span><span class="n">returnType</span><span class="o">.</span><span class="na">isArray</span><span class="o">());</span>
</code></pre></div>


<p>如果是数组的话，由于返回值是Object类型，需要通过Array工具类进行处理(见java api文档)</p>

<h3>其他:关于内部类调用的秘密</h3>

<h4>普通内部类</h4>

<div class="highlight"><pre><code class="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">List</span> <span class="n">stus</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">B</span><span class="o">().</span><span class="na">test</span><span class="o">();</span> <span class="o">}</span>
    <span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">stus</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>


<p>关于上面的内部类，为什么B能够调用到A的stus属性，通过观察生成的字节码，得到的实际结果是:</p>

<div class="highlight"><pre><code class="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">List</span> <span class="n">stus</span><span class="o">;</span>
    <span class="kd">static</span> <span class="n">List</span> <span class="n">access$0</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">stus</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">A$B</span><span class="o">(</span><span class="k">this</span><span class="o">).</span><span class="na">test</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span><span class="n">$B</span><span class="o">{</span>
    <span class="n">A</span> <span class="k">this</span><span class="n">$0</span><span class="o">;</span>
    <span class="n">A$B</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="n">$0</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="na">access</span><span class="n">$0</span><span class="o">(</span><span class="k">this</span><span class="n">$0</span><span class="o">),</span><span class="n">size</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>


<p>我们可以发现:</p>

<ol>
<li>A对B类需要访问的每一个私有属性生成对应的一个静态访问方法,B的访问就是通过这个私有方法的</li>
<li>生成B类实例的时候把A类实例引用传入并进行保存,所以每一个B类实例都有一个A类实例关联</li>
<li>通过反射可以看到新方法access$0和新内部变量this$0</li>
</ol>


<h4>静态内部类</h4>

<div class="highlight"><pre><code class="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">List</span> <span class="n">stus</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">B</span><span class="o">().</span><span class="na">test</span><span class="o">();</span> <span class="o">}</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">stus</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>


<p>对于静态内部类，情况就比较简单，得到的实际结果是:</p>

<div class="highlight"><pre><code class="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">List</span> <span class="n">stus</span><span class="o">;</span>
    <span class="kd">static</span> <span class="n">List</span> <span class="n">access$0</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">stus</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">A$B</span><span class="o">().</span><span class="na">test</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span><span class="n">$B</span><span class="o">{</span>
    <span class="n">A$B</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="na">access</span><span class="n">$0</span><span class="o">(),</span><span class="n">size</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>


<p>我们可以发现:</p>

<ol>
<li>A对B类需要访问的静态私有属性生成一个静态访问方法,B的访问就是通过这个私有方法的</li>
<li>由于是static方法，所以不需要保存实例的引用</li>
<li>通过反射可以看到新方法access$0</li>
</ol>


<p>所以，如果可以的话，优先使用静态内部类(特别是没有使用到内部普通变量的情况)。</p>

<h2>理解泛型</h2>

<p>java的泛型是擦除式,运行时没有泛型的概念.所以下面的代码会编译通过但执行报类型转换错误:</p>

<div class="highlight"><pre><code class="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">strs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
<span class="n">add2List</span><span class="o">(</span><span class="n">strs</span><span class="o">);</span>
<span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">strs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

<span class="c1">//add2List的实现</span>
<span class="kt">void</span> <span class="nf">add2List</span><span class="o">(</span><span class="n">List</span> <span class="n">lt</span><span class="o">){</span>
    <span class="n">lt</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>


<p>通过javap -c Test.class可以看到类似下面的指令:</p>

<div class="highlight"><pre><code class="java"><span class="c1">// String str = strs.get(0);</span>
<span class="mi">7</span><span class="o">:</span> <span class="n">invokeinterface</span> <span class="err">#</span><span class="mi">31</span><span class="o">,</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">//interfaceMethod java/util/List.get:(l)Ljava/lang/Object;</span>
<span class="mi">12</span><span class="o">:</span> <span class="n">checkcast</span> <span class="err">#</span><span class="mi">37</span><span class="o">;</span> <span class="c1">//class java/lang/String</span>

<span class="c1">// lt.add(1);</span>
<span class="mi">2</span><span class="o">:</span> <span class="n">invokestatic</span> <span class="err">#</span><span class="mi">41</span><span class="o">;</span> <span class="c1">//Method java/lang/Integer.valueOf:(l)Ljava/lang/Integer;</span>
<span class="mi">5</span><span class="o">:</span> <span class="n">invokeinterface</span> <span class="err">#</span><span class="mi">47</span><span class="o">,</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">//InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span>
</code></pre></div>


<p>很明显，在checkcast的时候会出错。</p>

<p>虽然说运行时不关注是否泛型，但是还是有办法可以找到一些泛型相关信息的。和泛型类型的类图如下面所示：
<img src="/assets/images/java_types.png" alt="java泛型类型结构" /></p>

<p>下面以Method为例进行描述(关于field之类的就不描述了)：</p>

<div class="highlight"><pre><code class="java"><span class="kd">public</span> <span class="n">T</span> <span class="nf">method2</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">,</span> <span class="kt">float</span><span class="o">[]</span> <span class="n">f</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span>
</code></pre></div>


<h3>分析入口</h3>

<div class="highlight"><pre><code class="java"><span class="n">Method</span><span class="err">#</span><span class="n">getGenericParameterTypes</span><span class="o">()</span>
<span class="n">Method</span><span class="err">#</span><span class="n">getGenericReturnType</span><span class="o">()</span>
<span class="n">Method</span><span class="err">#</span><span class="n">getGenericExceptionTypes</span><span class="o">()</span>
</code></pre></div>


<p>通过上面一些方法可以得到下面的类型关系：</p>

<div class="highlight"><pre><code class="java"><span class="n">T</span> <span class="o">-&gt;</span> <span class="n">TypeVariable</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="n">ParameterizedType</span>
<span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="o">-&gt;</span> <span class="n">ParameterizedType</span>
<span class="kt">float</span><span class="o">[]</span> <span class="o">-&gt;</span> <span class="n">GenericArrayType</span>
<span class="n">Exception</span> <span class="o">-&gt;</span> <span class="n">Class</span>
</code></pre></div>


<p>ParameterizedType描述的是一种多级泛型的关系，可以继续通过getActualTypeArguments继续进行处理,可以得到</p>

<div class="highlight"><pre><code class="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="n">Class</span>
<span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="o">-&gt;</span> <span class="n">WildcardType</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="n">TypeVariable</span>
</code></pre></div>


<p>处理Type是比较麻烦的事情，每种具体类型都有自己特殊的处理方法(见图所示)，但平时这个东西很少用到。</p>

<h2>New in JDK7</h2>

<p>jdk7以前有4种方法调用指令:</p>

<div class="highlight"><pre><code class="java"><span class="n">invokestatic</span> <span class="o">-&gt;</span> <span class="err">静态方法调用</span>
<span class="n">invokespecial</span> <span class="o">-&gt;</span> <span class="err">特殊方法</span><span class="o">(</span><span class="err">如构造方法</span><span class="o">)</span><span class="err">调用</span>
<span class="n">invokevirtual</span> <span class="o">-&gt;</span> <span class="err">普通方法调用</span>
<span class="n">invokeinterface</span> <span class="o">-&gt;</span> <span class="err">接口方法调用</span>
</code></pre></div>


<p>在jdk7中实现了新的规范jsr292，增加了新的字节码指令invokedynamic,通过下面的选项可以开启。</p>

<div class="highlight"><pre><code class="java"><span class="nl">XX:</span><span class="o">+</span><span class="n">UnlockExperimentalVMOptions</span>
<span class="nl">XX:</span><span class="o">+</span><span class="n">EnableInvokeDynamic</span>
<span class="nl">XX:</span><span class="o">+</span><span class="n">EnableMethodHandles</span>
</code></pre></div>


<p>该指令只需要制定方法名称，只要求引用非空对象而已，但javac还没法生成这样的指令。调用方式如下:</p>

<div class="highlight"><pre><code class="java"><span class="n">invokedynamic</span> <span class="err">#</span><span class="mi">10</span><span class="o">;</span> <span class="c1">//DynamicMethod java/lang/Object.lessThan:(Ljava/lang/Object;)</span>
</code></pre></div>


<p>但是可以有相关的api可以模拟出这种指令调用方式，如下(看上去和普通反射调用没什么明显不同)：</p>

<div class="highlight"><pre><code class="java"><span class="n">MethodType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MethodType</span><span class="o">.</span><span class="na">methodType</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">MutableCallSite</span> <span class="n">callSite</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MutableCallSite</span><span class="o">(</span><span class="n">type</span><span class="o">);</span>
<span class="n">MethodHandle</span> <span class="n">invoker</span> <span class="o">=</span> <span class="n">callSite</span><span class="o">.</span><span class="na">dynamicInvoker</span><span class="o">();</span>

<span class="n">MethodHandles</span><span class="o">.</span><span class="na">Lookup</span> <span class="n">lookup</span> <span class="o">=</span> <span class="n">MethodHandles</span><span class="o">.</span><span class="na">lookup</span><span class="o">();</span>
<span class="n">MethodHandle</span> <span class="n">mhMax</span> <span class="o">=</span> <span class="n">lookup</span><span class="o">.</span><span class="na">findStatic</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">&quot;max&quot;</span><span class="o">,</span> <span class="n">type</span><span class="o">);</span>

<span class="n">callSite</span><span class="o">.</span><span class="na">setTarget</span><span class="o">(</span><span class="n">mhMax</span><span class="o">);</span>
<span class="n">invoker</span><span class="o">.</span><span class="na">invokeWithArguments</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>
</code></pre></div>


<p>这种调用方式有几个关键的概念:</p>

<div class="highlight"><pre><code class="java"><span class="n">method</span> <span class="n">handle</span> <span class="err">方法句柄，是</span><span class="n">callsite</span><span class="err">的目标</span>
<span class="n">bootstrap</span> <span class="n">method</span> <span class="err">引导方法</span>
<span class="n">CallSite</span> <span class="err">调用点</span>
<span class="n">method</span> <span class="n">type</span> <span class="err">方法类型</span>
</code></pre></div>


<p>这个指令可以增强很多基于JVM的动态语言的方法调用性能，所以潜力很大，更多具体信息，可以参考下面的一些链接:
* http://www.infoq.com/cn/news/2011/01/invokedynamic
* http://icyfenix.iteye.com/blog/1392441
* http://book.51cto.com/art/201205/339215.htm
* http://www.from0to1.net/%E5%86%8D%E6%8E%A2-invokedynamic/</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20120903_jforum2-source-analytics.html">小毛的jforum2源码分析(旧)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-03T00:00:00+08:00" pubdate data-updated="true">Sep 3<span>rd</span>, 2012</time>
        
         | <a href="/blog/20120903_jforum2-source-analytics.html#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这个文章大约是08年的时候写的了，jforum是java中还算比较有名的开源论坛系统，我上一家公司拿它来做二次开发。jforum2是内部自己实现的mvc，到了jforum3的时候全部重写了，都使用开源框架来做，现在不知发展到什么情况了。所以，这里特指jforum2.</p>

<h2>正文</h2>

<p>怎么才算好的源码分析呢？当然我这个肯定不算。我想大概分为几个层面吧，写写注释那算最基本的了，
写写要点思路和难点，算是还不错拉，再难的就是跳出源码举一反三，形成自己的一套思路吧。好好努力吧。</p>

<p>这次针对的是jforum2.1.8,大概jforum团队已经没心情理这个版本了，都冲着jforum3去了。选择这个版本，
主要是因为jforum在java论坛类应用中算是佼佼者了，很多人都拿这个来做二次开发，而jforum3使用的是另外一套架构了，
而且还没完全release，所以斟酌一下，还是选择这个经典的版本。</p>

<p>关于jforum的介绍网上已经很多了，这里也简单抄录一段：JForum 是一个功能强大 ，易于管理的论坛。
它的设计完全遵从MVC设计模式，能够在任何Servlet容器与EJB服务器上运行。而且可以轻松的定制与扩展JForum论坛。
上面这段简述还是中肯的。另外，jforum是模仿phpbb写的，使用的是classic-blue风格，但不能自己选择风格，要的话只能自己修改了。
再说几句，说jforum比较优秀是因为java开源的论坛系列精品少，而且jforum的bug也真的不少，不信试试就知道了。
不过作为一个成型的组件，功能强大并且适合二次开发，还是应该列入考虑范围的。</p>

<p>不管怎样，jforum是个不错的学习范本，至少让你觉得写个山寨框架不是什么难事，
而事实也的确是这样的。重要的一点是，不要轻易拿出来害人就是了：)这里先列举出可能一些分析点：</p>

<p>● web.xml<br/>
● 初始化流程<br/>
● 处理请求流程(mvc)<br/>
● 文件监控<br/>
● 缓存实现<br/>
● 数据库访问实现<br/>
● 权限控制</p>

<p>首先了解一个web应用，首要的就是知道处理流程。首先来看看入口web.xml，里边的内容还是挺清晰的，
可以看到里边有个监听器ForumSessionListener，*.page的过滤器ClickstreamFilter，还有2个*.page的处理器，
其中InstallServlet是安装相关的，JForum则是前端处理器。</p>

<p>基本上<strong>整个流程</strong>就是</p>

<pre><code>client request -&gt; ForumSessionListener -&gt; ClickstreamFilter -&gt; JForum -&gt; server response.
</code></pre>

<p>ForumSessionListener实现了HttpSessionListener接口，但是只是对session destory做了处理，
在这个过程中，保存session的历史记录到DB，并清除用户信息和相关的security信息。
ClickstreamFilter实现了Filter接口，主要的任务就交给BotChecker了，是用来检测client是不是一个robot来的。
主要的工作还是在JForum上面，不过先来看看jforum是怎么检测robot的？</p>

<p>BotChecker只有一个静态工具方法isBot，首先是检测是否请求robot.txt(这是标准的robot协议文件),
接下去判断User－Agent头部，最后是判断remotehost。而已知的robot都是写在文件clickstream-jforum.xml
里边的(包括agent和host)，并通过ConfigLoader加载进来的(SAX方式)。</p>

<p>可以看到JForum和InstallServlet都继承了JForumBaseServlet这个HttpServlet，而JForumBaseServlet包括2个重要的方法init和startApplication。众所周知，init是servlet初始化时调用的方法，JForumBaseServlet里边的init方法的流程是：</p>

<pre><code>调用父类的init(正常情况这是必须调用的)  -&gt; 配置log4j -&gt; startSystemglobals(加载全局参数配置SystemGlobals.properties -&gt; 加载数据库配置database.driver.config(如mysql就是WEB-INF/config/database/mysql/mysql.properties)  -&gt; 加载自定义配置(默认的是jforum-custom.conf)) -&gt; 配置缓存引擎 -&gt; 配置freemarker模板引擎 -&gt; 加载模块配置modulesMapping.properties -&gt; 加载url映射配置urlPattern.properties -&gt; 加载I18n配置(languages/*) -&gt; 加载页面映射配置(templatesMapping.properties) -&gt; 加载BBcode配置bb_config.xml -&gt; 结束
</code></pre>

<p>jforum实现了自己的mvc，整个mvc的脉络就是</p>

<pre><code>client request -&gt; 解析url(urlPattern.properties),获取module/action/param -&gt; 通过module获取相应的module class，并通过action识别并调用相应的方法(modulesMapping.properties) -&gt; 使用dao完成业务逻辑 -&gt; 调用template进行渲染(templatesMapping.properties)
</code></pre>

<p>其实整个mvc和struts没什么两样的，具体的流程以后再提。</p>

<p>JForumBaseServlet里边的startApplication方法的流程是：</p>

<pre><code>加载通用sql文件sql.queries.driver(就是/database/generic/generic_queries.sql) -&gt; 加载特定sql文件(如mysql就是/database/mysql/mysql.sql) -&gt; 加载Quartz定时任务配置 -&gt; 加载登录验证器(验证方式) -&gt; 加载Dao实现方式 -&gt; 加载文件修改监听器 -&gt; 加载查询索引管理器 -&gt; 加载定时统计任务
</code></pre>

<p>jforum实现了自己的orm，当然不是hibernate那种，是类似ibatis的那种sql mapping，并提供了多套的sql文件来实现数据库无关的特性，
整个流程也是比较清晰的:</p>

<pre><code>加载数据库配置 -&gt; 加载sql mapping file -&gt; 设置DAO实现 -&gt; 通过named sql找到对应的sql(在*.sql里边对应着) -&gt; 运行出数据
</code></pre>

<p>继续重点。JForum的init流程如下：</p>

<pre><code>JForumBaseServlet.init -&gt; JForumBaseServlet.startApplication -&gt; 启动数据库 -&gt; 预加载一些数据到缓存中(ForumRepository[Categories,Forums,同时在线最大人数，最后登录用户，注册用户数等等],用户等级,表情数据，屏蔽列表) -&gt; 结束
</code></pre>

<p>上面简单提到了<strong>Jforum处理请求的过程</strong>，现在在来看看这个过程，就是service方法，这次采用代码概要的方式展示：</p>

<div class="highlight"><pre><code class="java"> <span class="c1">// 初始化JForumExecutionContext</span>
<span class="n">JForumExecutionContext</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="c1">// 包装request和response</span>
<span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WebRequestContext</span><span class="o">(</span><span class="n">req</span><span class="o">);</span>
<span class="n">response</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WebResponseContext</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
<span class="c1">// 检查数据库状态</span>
<span class="k">this</span><span class="o">.</span><span class="na">checkDatabaseStatus</span><span class="o">();</span>
<span class="c1">// 创建JForumContext并设置到JForumExecutionContext中去</span>
<span class="o">.......</span>
<span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
<span class="c1">// 刷新session          </span>
<span class="n">utils</span><span class="o">.</span><span class="na">refreshSession</span><span class="o">();</span>
<span class="c1">// 加载用户权限        </span>
<span class="n">SecurityRepository</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">SessionFacade</span><span class="o">.</span><span class="na">getUserSession</span><span class="o">().</span><span class="na">getUserId</span><span class="o">());</span>
<span class="c1">// 预加载模板需要的上下文</span>
<span class="n">utils</span><span class="o">.</span><span class="na">prepareTemplateContext</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">forumContext</span><span class="o">);</span>
<span class="c1">// 从request中解析module name</span>
<span class="n">String</span> <span class="n">module</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getModule</span><span class="o">();</span>
<span class="c1">// module name  -&gt; module class</span>
<span class="n">String</span> <span class="n">moduleClass</span> <span class="o">=</span> <span class="n">module</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">ModulesRepository</span><span class="o">.</span><span class="na">getModuleClass</span><span class="o">(</span><span class="n">module</span><span class="o">)</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
<span class="c1">// 判断是否在ban list里边</span>
<span class="o">......</span>
<span class="kt">boolean</span> <span class="n">shouldBan</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">shouldBan</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">());</span>
<span class="c1">// 主角出场</span>
<span class="n">out</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">processCommand</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">encoding</span><span class="o">,</span> <span class="n">context</span><span class="o">,</span> <span class="n">moduleClass</span><span class="o">);</span>
<span class="c1">// 扫尾工作,例如db的rollback</span>
<span class="k">this</span><span class="o">.</span><span class="na">handleFinally</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">forumContext</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
</code></pre></div>


<p>processCommand会调用Command的process方法：</p>

<div class="highlight"><pre><code class="java"><span class="c1">// 获取一个module实例(继承了Command)</span>
<span class="n">Command</span> <span class="n">c</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">retrieveCommand</span><span class="o">(</span><span class="n">moduleClass</span><span class="o">);</span>
<span class="c1">// 进入process</span>
<span class="n">Template</span> <span class="n">template</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">context</span><span class="o">);</span>
<span class="c1">// 这里开始是process方法</span>
<span class="c1">//获取action</span>
<span class="n">String</span> <span class="n">action</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">request</span><span class="o">.</span><span class="na">getAction</span><span class="o">();</span>
<span class="c1">//如果不是ignore的，就调用这个action</span>
<span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">ignoreAction</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="n">action</span><span class="o">,</span> <span class="n">NO_ARGS_CLASS</span><span class="o">).</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">NO_ARGS_OBJECT</span><span class="o">);}</span>
<span class="c1">//如果是转发的，就把TemplateName清空</span>
<span class="k">if</span> <span class="o">(</span><span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">getRedirectTo</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">setTemplateName</span><span class="o">(</span><span class="n">TemplateKeys</span><span class="o">.</span><span class="na">EMPTY</span><span class="o">);}</span>
<span class="c1">//不是转发且attribute里边存在template，则设置为templateName</span>
<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">&quot;template&quot;</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">setTemplateName</span><span class="o">((</span><span class="n">String</span><span class="o">)</span><span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">&quot;template&quot;</span><span class="o">));}</span>
<span class="c1">//是否coustomContent？例如下载，验证码子类的不需要页面的操作</span>
<span class="k">if</span> <span class="o">(</span><span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">isCustomContent</span><span class="o">())</span> <span class="o">{</span><span class="k">return</span> <span class="kc">null</span><span class="o">;}</span>
<span class="c1">//返回一个template</span>
<span class="k">return</span> <span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">templateConfig</span><span class="o">().</span><span class="na">getTemplate</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">StringBuffer</span><span class="o">(</span><span class="n">SystemGlobals</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">ConfigKeys</span><span class="o">.</span><span class="na">TEMPLATE_DIR</span><span class="o">)).</span>
                <span class="n">append</span><span class="o">(</span><span class="sc">&#39;/&#39;</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">templateName</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>
<span class="c1">// 从process出来，回到processCommand</span>
<span class="c1">// 设置content type</span>
<span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="n">contentType</span><span class="o">);</span>
<span class="c1">//生成页面并flush</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">isCustomContent</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="n">OutputStreamWriter</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">(),</span> <span class="n">encoding</span><span class="o">));</span>
                <span class="n">template</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">getTemplateContext</span><span class="o">(),</span> <span class="n">out</span><span class="o">);</span>
                <span class="n">out</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div>


<p>这是一般的流程，就像上面提到的customContent，就是要自己处理了，可以参考CaptchaAction.generate().</p>

<p>这样的话，如果我们要增加一些action进行<strong>二次开发</strong>的话，大体的流程就是，增加一个继承了Command的类，
例如叫ExampleAction,定义一个方法，例如叫test()，在urlPattern.properties中定义一个映射,
例如为example.test.1 = forum_id，再在modulesMapping.properties中定义module class的映射，
如example = ExampleAction，最后我们在templatesMapping.properties定义个模板的映射，
如：example.test = example_test.htm。现在假设我们的请求url是/example/test/1,再来看看test里边的一些方法：</p>

<div class="highlight"><pre><code class="java"><span class="k">this</span><span class="o">.</span><span class="na">request</span><span class="o">.</span><span class="na">getIntParameter</span><span class="o">(</span><span class="s">&quot;forum_id&quot;</span><span class="o">))</span>  <span class="c1">//获取参数，得到1</span>
<span class="k">this</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;obj&quot;</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span> <span class="c1">//把结果写入context，这样可以在template中获取到</span>
<span class="k">this</span><span class="o">.</span><span class="na">setTemplateName</span><span class="o">(</span><span class="s">&quot;example.test&quot;</span><span class="o">);</span><span class="c1">//设置template的名字</span>
</code></pre></div>


<p>这样的简单流程应该还比较好理解吧?</p>

<p>另外，还可以看出，jforum使用了自己的一套映射机制，这是通过urlPattern.properties来定义的
(参考上面JForumBaseServlet的init流程)，这是在JForumBaseServlet的loadConfigStuff方法的第一行实现的，
并加载到UrlPatternCollection中去，如下所示：</p>

<div class="highlight"><pre><code class="java"><span class="n">Properties</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
<span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">SystemGlobals</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">ConfigKeys</span><span class="o">.</span><span class="na">CONFIG_DIR</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;/urlPattern.properties&quot;</span><span class="o">);</span>
<span class="n">p</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>

<span class="k">for</span> <span class="o">(</span><span class="n">Iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">();</span> <span class="n">iter</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
   <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="n">iter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
   <span class="n">UrlPatternCollection</span><span class="o">.</span><span class="na">addPattern</span><span class="o">((</span><span class="n">String</span><span class="o">)</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div>


<p>可以知道这里的key和value都是String来的</p>

<div class="highlight"><pre><code class="java"><span class="n">UrlPatternCollection</span><span class="o">.</span><span class="na">patternsMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="k">new</span> <span class="n">UrlPattern</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">));</span>
</code></pre></div>


<p>但在addPattern方法里边其实是生成一个UrlPattern作为value，如何<strong>构造一个UrlPattern</strong>可以看看代码，
举例来说把，对于example.hello.2=a,b,这样会生成一个UrlPattern,里边的内容是name为example.hello.2,value为a,b.
而size和vars是用a,b解析出来的，用来表示一共有多少个参数，参数名组成的数组。
所以UrlPattern存储的就是一个url格式的定义，而放在UrlPatternCollection里边的一系列的url映射格式是在请求的url解析的时候用到的。</p>

<p>现在再分析一下jforum怎么使用这个UrlPatternCollection的?按照我们不严格的思路，应该是service中处理url，
获取.page前面的一部分,如/example/hello/2/1，用/做一下split，获取module name，action name,
把最后的作为参数，用module,action,参数个数组成一个key(example.hello.2),通过UrlPatternCollection找到对应的UrlPattern，
通过里边的格式对应(vars里边的参数名和url的参数值)就可以把参数添加到request的parameters里边去。
实际的情况也差不多就这个样。在说到jforum中的service方法的时候，简单提到过request和response是经过包装的:</p>

<div class="highlight"><pre><code class="java"><span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WebRequestContext</span><span class="o">(</span><span class="n">req</span><span class="o">);</span>
<span class="n">response</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WebResponseContext</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
</code></pre></div>


<p>WebResponseContext只是简单的delegate给HttpServletResponse(这样做的好处是全部方法都限制在ResponseContext中)，
而WebRequestContext是继承了HttpServletRequestWrapper并实现了RequestContext接口。
所以WebRequestContext是一个HttpRequest，但是通过RequestContext接口实现了一些特定的方法就是了，
例如getModule/getAction，而这个解析url的过程是在构建WebRequestContext对象的过程中实现的。
可以看看WebResponseContext的构造方法，这里就不详细说了。注意的是，所有的parameters最后都保存到query(一个私有的map)里边去的。
还有就是上面说到的jforum的特定url映射机制，这是通过WebRequestContext的parseFriendlyURL方法实现的，
原理就和上面提到的那样，也不详说了。</p>

<p>到这里，基本上整个处理流程就差不多了。现在来说说jforum里边的文件修改监听器(JForumBaseServer的startApplication流程)，
如果你在使用jforum的过程中，修改了某些文件如*.sql，jforum就会重新加载修改后的配置。
我原来以为是用quartz框架来实现的，后来才知道是用jdk的TimerTask类来实现的。
请看ConfigLoader的listenForChanges方法：</p>

<div class="highlight"><pre><code class="java"><span class="n">FileMonitor</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">addFileChangeListener</span><span class="o">(</span><span class="k">new</span> <span class="n">QueriesFileListener</span><span class="o">(),</span>
                <span class="n">SystemGlobals</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">ConfigKeys</span><span class="o">.</span><span class="na">SQL_QUERIES_GENERIC</span><span class="o">),</span> <span class="n">fileChangesDelay</span><span class="o">);</span>
</code></pre></div>


<p>这里给各个部分分一下责任，FileMonitor是大管家，负责管理所有的文件监听器；FileChangeListener是一个监听器接口，
只有一个方法，就是fileChanged(String filename)，意思就是对某个filename的修改作出怎样的反应。
使用的方法也很简单，就是实现一个FileChangeListener，并和监控的文件名，检查间隔作为参数传入就可以生效了。
FileMonitor里边的实现原理就是，通过一个map(timerEntries)来保存(文件名/timertask),
每次加入一个监听器的时候，会根据文件名先移出原来的文件监听器(缺点是只能能对一个文件添加一个监听器)，
然后构建一个TimerTask并加入到timerEntries中去。关于TimerTask的具体用法，可以参考api。</p>

<p>作为一个论坛，应用层缓存这样的东西似乎必不可少，jforum也提供了缓存配置(上面也提到一些)。
jforum提供了数种<strong>缓存实现</strong>(JForumBaseServlet的init流程)，分别是DefaultCacheEngine(简单的内存实现),
JBossCacheEngine，EhCacheEngine。，请看ConfigLoader的startCacheEngine方法，
流程大概就是得到cacheEngine的实现配置(SystemGlobals.properties中配置cache.engine.implementation)，
然后产生CacheEngine的实例，调用它的init方法进行初始化，然后找到所有的可缓存类(实现了Cacheable接口，并在SystemGlobals.properties中配置cacheable.objects)，最后把cacheEngine注入进去获得cache的能力。
虽然jforum自己实现了许多这样的注入(除了cacheEngine，还有db，dao等等)，
虽然达到了一定的的目的，可是怎么说还是到处充满了Singleton的实现(参考spring2.5文档3.9. 粘合代码和可怕的singleton)，
为了寻求更好的组织方式(例如使用ioc来管理对象，使用成熟的orm来隔离数据库)和获得更多的用户群(选择更广泛使用的框架帮助)，
大概才会萌发jforum3的想法吧。</p>

<p>顺便提一下jforum的<strong>Dao实现方式</strong>(参考JForumBaseServlet的startApplication流程)，
参考ConfigLoader的loadDaoImplementation方法，原理就是通过配置dao.driver(在特定的数据库配置里边如mysql.properties):</p>

<pre><code>获取到DataAccessDriver的实现 -&gt; 初始化DataAccessDriver -&gt; 获取到所有的Dao实现。
</code></pre>

<p>可以这么理解，实现一个DataAccessDriver就获得一整套Dao的实现方式，对于dao里边的实现方法，给个范例：</p>

<div class="highlight"><pre><code class="java"><span class="c1">//例行公事</span>
<span class="n">PreparedStatement</span> <span class="n">p</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="c1">//获得connect，并执行named sql</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">getConnection</span><span class="o">().</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">SystemGlobals</span><span class="o">.</span><span class="na">getSql</span><span class="o">(</span><span class="s">&quot;GroupModel.selectById&quot;</span><span class="o">));</span>
<span class="n">p</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">groupId</span><span class="o">);</span>
<span class="n">rs</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>
<span class="n">Group</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Group</span><span class="o">();</span>
<span class="c1">//循环resultset进行处理</span>
<span class="k">if</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span><span class="n">g</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getGroup</span><span class="o">(</span><span class="n">rs</span><span class="o">);}</span>
</code></pre></div>


<p>整个实现很直白，就是一个jdbc实现方式来的。对于如何获取connection，查看JForumExecutionContext的getConnection(),可以注意到这么一句：</p>

<div class="highlight"><pre><code class="java"><span class="n">c</span> <span class="o">=</span> <span class="n">DBConnection</span><span class="o">.</span><span class="na">getImplementation</span><span class="o">().</span><span class="na">getConnection</span><span class="o">();</span>
</code></pre></div>


<p>也是比较清晰的，另外可以知道的是，在每次请求的过程中，connection只会获取一次，
并在第一次获取到以后放到ThreadLocal里边去,这样在每个线程中保留一份数据(正确理解TheradLocal )，
在请求请求结束以后才释放connection(service流程中的handleFinally方法)。</p>

<p>JForumExecutionContext，如字面意，就是请求执行的上下文，例如上面提到的数据库连接，
还有ForumContext(放着和request，response相关的信息)，context(freemarker的上下文变量)，
redirectTo(转发地址)，contentType(响应内容格式)，isCustomContent(不使用默认渲染，上面有提到)，
enableRollback(db是否会滚)。</p>

<p>jforum是可以配置权限的，可控制的权限类型放在SecurityConstants里边，
对应的配置界面是根据permissions.xml生成的(参考GroupAction的permissions)。而每个用户的权限(PermissionControl)是通过SecurityRepository来管理的</p>

<pre><code>最用形成的权限系统是role(权限)－group(用户组,可以多级)－用户这样的结构图。
</code></pre>

<p>如何判断权限?
对于一个用户来说，为了获取用户的权限(PermissionControl)，流程是这样的(详细看SecurityRepository的load方法)：</p>

<pre><code>获取用户信息 -&gt; 获取用户的所有groupid并组成一个用逗号隔开的字符串groupids  -&gt; 根据groupids获取所有的name/role_value -&gt; 组装成RoleValueCollection －&gt; 生成RoleCollection -&gt; 最后生成PermissionControl
</code></pre>

<p>判断权限是使用SecurityRepository的canAccess(int userId, String roleName, String value)方法：</p>

<pre><code>根据userid获取PermissionControl-&gt; 如果value参数为空的话，就判断是否拥有该roleName(通过内部的RoleCollection对象的keys),就是是否含有该权限 -&gt; 如果value参数不为空的话，除了需要含有该权限，还要拥有相应的rolevalue(通过内部的RoleCollection对象的values)。参数中的value指数可以为论坛分类id，论坛id之类，随业务而定。
</code></pre>

<p>总体上jforum还算清晰，大部分的业务代码没有细看(那些Command类)，有兴趣可以对照着写，
大体分为三个包(admin是管理，jforum是公共页面，install是安装页面)。</p>

<p>既然说到验证，就顺便要说说jforum的<strong>sso验证机制</strong>
官方文档:</p>

<pre><code>http://www.jforum.net/doc/SSO
http://www.jforum.net/doc/ImplementSSO
http://www.jforum.net/doc/SSOcookies
http://www.jforum.net/doc/SSOremote
</code></pre>

<p>有上面这些文档基本可以自己实现一个，主要就是实现net.jforum.sso接口就是了。</p>

<p>在Jforum的service方法里边有段(service流程中的刷新session)：</p>

<div class="highlight"><pre><code class="java"><span class="n">ControllerUtils</span> <span class="n">utils</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ControllerUtils</span><span class="o">()</span>
<span class="n">utils</span><span class="o">.</span><span class="na">refreshSession</span><span class="o">();</span><span class="c1">//重点</span>
</code></pre></div>


<p>里边提到，在没有usersession的情况下，如果配置的验证类型是sso(authentication.type)：</p>

<pre><code>调用checkSSO(UserSession userSession)的方法 -&gt; 生成SSO实例(使用sso.implementation来配置) -&gt; 调用authenticateUser(RequestContext request)返回username -&gt; 假如取不到的username，就设为匿名 -&gt; 否则，如果不存在该用户(utils.userExists(username)则注册一个(utils.register(password, email)) -&gt; 假如已经存在,则让用户登录(configureUserSession(userSession, utils.getUser()))
</code></pre>

<p>当已经存在usersession的时候，并且验证方式是sso的时候，就是验证是否有效(sso.isSessionValid(userSession, request))。
所以，整个过程和官方文档提到的流程是一样的，如果要实现自己的sso，这是实现SSO接口，
使用authenticateUser来验证不存在usersession的情况，并返回username or null，
而使用isSessionValid来判断一个已经存在的usersession是否有效。
参考上面几个连接文档，实现和已有系统的sso集成，还是比较清晰明了的。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/14/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/12/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/20131227_android-tcpdump-netcat-addon.html">对UC文章《实时监控Android设备网络包》的补充</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131126_connection-leak.html">连接池泄露定位案例</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131120_notebook-system-install.html">周日笔记本系统安装记事</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131108_mission-estimate.html">谈任务分解与评估</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131106_jsch-session-connect.html">小心jsch的sftp连接泄露</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131103_word-contact.html">单词接龙问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131029_youdao-note.html">有道云笔记使用感受</a>
      </li>
    
      <li class="post">
        <a href="/blog/20131025_how-to-excel.html">excel读书心得</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130930_des.html">DES加解密总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130921_books.html">那些年，我读过的技术书</a>
      </li>
    
  </ul>
</section>

<section>
<iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=8&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=1735848865&verifier=fa40be14&dpc=1"></iframe>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/mccxj">@mccxj</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'mccxj',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - 蔡晓建 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'mccxj';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
